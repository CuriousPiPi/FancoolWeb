<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Chart Renderer</title>

  <!-- head：新增 BootCDN 的建链提示，并将主源改为 BootCDN -->
  <link rel="preconnect" href="https://cdn.bootcdn.net" crossorigin>
  <link rel="dns-prefetch" href="//cdn.bootcdn.net">

  <!-- 将原来的 jsDelivr 主源替换为 BootCDN -->
  <script id="echarts-cdn" defer src="/static/vendor/echarts/5.4.2/echarts.min.js"></script>
  <style>
    html,body{height:100%;margin:0}
    #chart{width:100%;height:100%; position: relative; overflow: hidden;}

    :root{
      --bg-bubble:#ffffff;
      --border-color:#e5e7eb;
      --text-primary:#1f2937;
      --text-:#6b7280;
      --accent:#2563eb;
      --accent-weak:#93c5fd;
      --ok:#16a34a;
      --ok-pressed:#15803d;
      --shadow:0 6px 20px rgba(0,0,0,0.12);
      --shadow-strong:0 8px 24px rgba(0,0,0,0.18);
    }
    [data-theme="dark"]{
      --bg-bubble:#1f293700;
      --border-color:#374151;
      --text-primary:#f3f4f6;
      --text-:#9ca3af;
      --accent:#60a5fa;
      --accent-weak:#bfdbfe;
      --ok:#16a34a;
      --ok-pressed:#15803d;
      --shadow:0 6px 20px rgba(0,0,0,0.35);
      --shadow-strong:0 8px 24px rgba(0,0,0,0.45);
    }

    /* 推迟隐藏浮层的布局/绘制，避免首屏成本 */
    .fit-buttons,
    .fit-bubble{
     content-visibility: auto;
     contain-intrinsic-size: 120px 80px; /* 估算尺寸，避免 CLS */
    }

    .fit-buttons{
      position: absolute;
      z-index: 2147483645;
      visibility: hidden;
      display: flex;
      gap: 6px;
      pointer-events: auto;
    }
    .fit-buttons .btn{
      appearance: none;
      border: 1px solid var(--border-color);
      background: var(--bg-bubble);
      color: var(--text-primary);
      font-size: 12px;
      font-weight: 700;
      padding: 6px 8px;
      border-radius: 8px;
      cursor: pointer;
      user-select: none;
      line-height: 1;
      box-shadow: var(--shadow);
      transition: transform .02s ease-in-out, background-color .15s ease, color .15s ease;
    }
    .fit-buttons .btn:active{ transform: translateY(1px); }
    .fit-buttons .btn.active{
      background: var(--ok);
      color: #fff;
      border-color: var(--ok);
    }
    .fit-buttons .btn.active:active{ background: var(--ok-pressed); }

    .fit-bubble{
      position: fixed;
      z-index: 2147483645;
      visibility: hidden;
      min-width: 260px;
      max-width: 420px;
      max-height: 60vh;
      overflow: auto;
      background: var(--bg-bubble);
      backdrop-filter: blur(4px) saturate(120%);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      box-shadow: var(--shadow-strong);
      padding: 10px 12px;
      cursor: grab; 
      touch-action: none;
    }
    .fit-bubble.dragging{ cursor: grabbing; }
    .fit-bubble .head{ display:flex; align-items:center; gap:10px; margin-bottom: 6px; }
    .fit-bubble .title{ font-weight: 800; color: var(--text-primary); font-size: 13px; line-height: 1.2; white-space: nowrap; }
    .fit-bubble .x-input{ margin-left:auto; display:flex; align-items:center; gap:6px; font-size:12px; color: var(--text-); white-space: nowrap; }
    .fit-bubble input[type="number"]{
      width: 10ch; font-size: 12px; padding: 4px 6px; border: 1px solid var(--border-color);
      border-radius: 8px; background: transparent; color: var(--text-primary); outline: none;
    }
    .fit-bubble .row{ display:flex; align-items:center; gap:8px; margin: 4px 0; color: var(--text-primary); font-size: 13px; }
    .fit-bubble .row .dot{ width:10px; height:10px; border-radius:50%; flex:0 0 auto; }
    .fit-bubble .hint{ color: var(--text-); font-size: 11px; margin-top: 6px; }

    .fit-pointer{
      position: absolute;
      z-index: 1000;
      visibility: hidden;
      pointer-events: none;
    }
    .fit-pointer .line{
      position:absolute; top:0; bottom:0; width: 2px; transform: translateX(-1px); background: var(--accent); opacity: 0.95;
    }
    .fit-pointer .handle{
      position:absolute; bottom:-22px; left:-8px; width:16px; height:24px; border-radius:4px; background: var(--accent);
      box-shadow: var(--shadow); cursor: grab; touch-action: none; pointer-events: auto;
    }
    .fit-pointer .handle::after{
      content:""; position:absolute; left:50%; transform: translateX(-50%); top:-7px;
      width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 9px solid var(--accent);
    }

    .fit-narrow-hint{
      position:absolute; z-index:2147483643; font-size:11px; color: var(--text-); pointer-events:none; user-select:none; white-space:nowrap;
    }
  </style>
</head>
<body>
  <div id="chart"></div>

<script>
(function () {
  // ============ 关键修复：ECharts 就绪门闸 + 兜底 ============
  // NEW: 与父页的握手与重试，避免消息竞态丢失
    let helloTimer = null;
    let helloAttempts = 0;
    const helloMax = 6;

    function pingParentForData(reason){
      try {
        window.parent.postMessage({
          type: 'chart:hello',
          payload: { reason, ts: Date.now(), source: 'iframe' }
        }, window.location.origin);
      } catch(_) {}
    }

    function ensurePayloadHandshake(){
      if (lastPayload) return;
      clearInterval(helloTimer);
      helloAttempts = 0;
      // 立即请求一次
      pingParentForData('init');
      // 后续重试（每 600ms 一次，最多 6 次）
      helloTimer = setInterval(() => {
        if (lastPayload || helloAttempts >= helloMax) {
          clearInterval(helloTimer);
          return;
        }
        helloAttempts++;
        pingParentForData('retry-' + helloAttempts);
      }, 600);
    }

  const ECHARTS_GLOBAL_KEY = 'echarts';
  let echartsReady = typeof window[ECHARTS_GLOBAL_KEY] !== 'undefined';
  const echartsWaiters = [];
  let echartsLoadTimedOut = false;

  function markEchartsReady(){
    if (echartsReady) return;
    echartsReady = true;
    const cbs = echartsWaiters.splice(0);
    cbs.forEach(cb => { try { cb(); } catch(_) {} });
  }
  function onEchartsReady(cb){
    if (echartsReady) { cb(); return; }
    echartsWaiters.push(cb);
  }
  // 监听主 CDN 脚本
  (function wireEchartsLoad(){
    if (echartsReady) return;

    const s = document.getElementById('echarts-cdn');
    if (!s) return;

    const fallbacks = [
      'https://cdn.jsdelivr.net/npm/echarts@5.4.2/dist/echarts.min.js',
      'https://unpkg.com/echarts@5.4.2/dist/echarts.min.js'
    ];
    let fbIndex = 0;

    function injectNextFallback(){
      if (echartsReady || fbIndex >= fallbacks.length) return;
      const alt = document.createElement('script');
      alt.defer = true;
      alt.crossOrigin = 'anonymous';
      alt.src = fallbacks[fbIndex++];
      alt.addEventListener('load', () => { markEchartsReady(); ensurePayloadHandshake(); }, { once:true });
      alt.addEventListener('error', injectNextFallback, { once:true });
      document.head.appendChild(alt);
    }

    s.addEventListener('load', () => { markEchartsReady(); ensurePayloadHandshake(); }, { once:true });
    s.addEventListener('error', () => { injectNextFallback(); }, { once:true });

    // 轮询仅用于标记就绪
    const start = performance.now();
    const tm = setInterval(() => {
      if (typeof window[ECHARTS_GLOBAL_KEY] !== 'undefined') {
        clearInterval(tm); markEchartsReady(); ensurePayloadHandshake();
      } else if (performance.now() - start > 15000) {
        clearInterval(tm); echartsLoadTimedOut = true;
      }
    }, 50);
  })();

  // 小工具：空闲时做非关键工作
  const onIdle = (cb) => ('requestIdleCallback' in window)
    ? requestIdleCallback(cb, { timeout: 1000 })
    : setTimeout(cb, 0);

  // ===========================================================

  let chart;
  let lastOption = null;
  let lastPayload = null;
  let isFs = false;
  let lastIsNarrow = null;

  let bubbleUserMoved = false;
  const bubblePos = { left: null, top: null };

  let xAxisOverride = null;
  let axisSnapSuppressUntil = 0;

  window.__FS_TOGGLE_OFFSET = window.__FS_TOGGLE_OFFSET || { x: 0, y: 0 };
  const TITLE_GLUE = '  -  ';

  function isMobile(){
    return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent)
      || (window.matchMedia && window.matchMedia('(pointer:coarse)').matches);
  }
  function layoutIsNarrow() {
    const w = chart && typeof chart.getWidth === 'function'
      ? chart.getWidth()
      : (typeof window !== 'undefined' ? window.innerWidth : 0);
    let narrow = w < 600;
    if (isFs && isMobile()) narrow = false;
    return narrow;
  }

  const FIT_ALGO_NAME = '趋势拟合';
  let showRawCurves = true;
  let showFitCurves = false;

  const xQueryByMode = { rpm: null, noise_db: null };
  const fitModelsCache = { rpm: new Map(), noise_db: new Map() };
  let fitUIInstalled = false;

  // 复用测量上下文
  const __textMeasureCtx = (() => {
    const c = document.createElement('canvas');
    return c.getContext('2d');
  })();

  function init() {
    if (!window.echarts) return; // 双保险
    chart = echarts.init(document.getElementById('chart'), null, {
      renderer:'canvas',
      devicePixelRatio: window.devicePixelRatio || 1
    });

    installChartResizeObserver();
    
    window.addEventListener('resize', () => {
      if (!chart) return;
      const nowNarrow = layoutIsNarrow();
      if (lastIsNarrow === null) lastIsNarrow = nowNarrow;

      if (nowNarrow !== lastIsNarrow) {
        lastIsNarrow = nowNarrow;
        if (lastPayload) render(lastPayload);
        else chart.resize();
      } else {
        chart.resize();
        if (lastOption) {
          const { x, y, visible } = computePrefixCenter(lastOption);
          placeAxisOverlayAt(x, y, visible && !lastOption.__empty);
          placeFitUI();
          repaintPointer();
        }
      }
    }, { passive:true });

    document.addEventListener('fullscreenchange', async () => {
      isFs = !!document.fullscreenElement;
      if (!isFs) {
        if (screen.orientation && screen.orientation.unlock) {
          try { screen.orientation.unlock(); } catch(_) {}
        }
      }
      const nowNarrow = layoutIsNarrow();
      if (lastIsNarrow === null) lastIsNarrow = nowNarrow;

      if (nowNarrow !== lastIsNarrow) {
        lastIsNarrow = nowNarrow;
        if (lastPayload) render(lastPayload);
        else chart && chart.resize();
      } else {
        chart && chart.resize();
        if (lastOption) {
          const { x, y, visible } = computePrefixCenter(lastOption);
          placeAxisOverlayAt(x, y, visible && !lastOption.__empty);
          placeFitUI();
          repaintPointer();
        }
      }
    }, { passive:true });

    chart.on('legendselectchanged', () => {
      if (showFitCurves) refreshFitBubble();
    });
    chart.on('dataZoom', () => {
      clampXQueryIntoVisibleRange();
      repaintPointer();
      if (showFitCurves) refreshFitBubble();
    });

    if (!fitUIInstalled) {
      onIdle(() => {
        ensureFitUI();
        fitUIInstalled = true;
        toggleFitUI(showFitCurves && !layoutIsNarrow());
        placeFitUI();
        repaintPointer();
        // 新增：再等一帧，确保 convertToPixel 可用
        requestAnimationFrame(() => repaintPointer());
      });
    }
  }

  // 轴开关与 UI（原逻辑略，未删减）
  let axisSnapSuppressTimer = null;
  function updateAxisSwitchPosition(opts = {}) {
    const { force = false, animate = false } = opts;
    if (!force && performance.now() < axisSnapSuppressUntil) return;
    const track  = document.getElementById('xAxisSwitchTrack');
    const slider = document.getElementById('xAxisSwitchSlider');
    if (!track || !slider) return;

    const sliderWidth = slider.offsetWidth || 0;
    const trackWidth  = track.offsetWidth || 0;
    const maxX = Math.max(0, trackWidth - sliderWidth);

    const currType = currentXModeFromPayload(lastPayload);
    const toNoise  = (currType === 'noise_db');

    slider.style.transition = animate ? 'transform .25s ease' : 'none';
    slider.style.transform  = `translateX(${toNoise ? maxX : 0}px)`;
    track.setAttribute('aria-checked', String(toNoise));
  }

  function ensureAxisOverlay(){
    let overlay = document.getElementById('chartXAxisOverlay');
    if (!overlay){
      overlay = document.createElement('div');
      overlay.id = 'chartXAxisOverlay';
      overlay.className = 'chart-xaxis-overlay';
      overlay.setAttribute('aria-label','X轴切换');
      overlay.innerHTML = `
        <div class="switch-container" id="xAxisSwitchContainer">
          <div class="switch-track" id="xAxisSwitchTrack">
            <div class="switch-slider" id="xAxisSwitchSlider">
              <span class="switch-label switch-label-right">转速</span>
              <span class="switch-label switch-label-left">噪音</span>
            </div>
          </div>
        </div>`;
      document.getElementById('chart').appendChild(overlay);
      bindXAxisSwitch();
      requestAnimationFrame(() => updateAxisSwitchPosition({ force: true, animate: false }));
    }
    return overlay;
  }

  function bindXAxisSwitch(){
    const xAxisSwitchTrack = document.getElementById('xAxisSwitchTrack');
    const xAxisSwitchSlider = document.getElementById('xAxisSwitchSlider');
    if (!xAxisSwitchTrack || !xAxisSwitchSlider) return;

    let sliderWidth = 0, trackWidth = 0, maxX = 0;
    let dragging = false, dragMoved = false, startX = 0, base = 0, activePointerId = null;

    try {
      xAxisSwitchTrack.setAttribute('role', 'switch');
      xAxisSwitchTrack.setAttribute('aria-checked', String((currentXModeFromPayload(lastPayload) || 'rpm') !== 'rpm'));
    } catch(_) {}

    function measure() {
      sliderWidth = xAxisSwitchSlider.offsetWidth || 0;
      trackWidth  = xAxisSwitchTrack.offsetWidth || 0;
      maxX = Math.max(0, trackWidth - sliderWidth);
    }
    function pos(type, animate = true) {
      const toNoise = (type === 'noise_db' || type === 'noise');
      const x = toNoise ? maxX : 0;
      xAxisSwitchSlider.style.transition = animate ? 'transform .25s ease' : 'none';
      xAxisSwitchSlider.style.transform  = `translateX(${x}px)`;
      xAxisSwitchTrack.setAttribute('aria-checked', String(toNoise));
    }
    function protectSliderAnimationWindow() {
      axisSnapSuppressUntil = performance.now() + 360;
      clearTimeout(axisSnapSuppressTimer);
      axisSnapSuppressTimer = setTimeout(() => { axisSnapSuppressUntil = 0; }, 400);
    }
    xAxisSwitchSlider.addEventListener('transitionend', () => {
      axisSnapSuppressUntil = 0;
    });

    function applyType(newType) {
      const normalized = (newType === 'noise') ? 'noise_db' : newType;
      if (normalized !== 'rpm' && normalized !== 'noise_db') return;
      if (xAxisOverride === normalized) return;
      xAxisOverride = normalized;
      try { localStorage.setItem('x_axis_type', normalized); } catch(_) {}
      pos(normalized, true);
      protectSliderAnimationWindow();
      if (lastPayload) render(lastPayload);
      try {
        window.parent.postMessage({
          type:'chart:xaxis-type-changed',
          payload:{ x_axis_type: normalized, fullscreen: !!document.fullscreenElement, source:'iframe' }
        }, window.location.origin);
      } catch(_){}
    }
    function nearestType() {
      const m = new DOMMatrix(getComputedStyle(xAxisSwitchSlider).transform);
      const cur = m.m41 || 0;
      return cur > maxX / 2 ? 'noise_db' : 'rpm';
    }

    function onPointerDown(e) {
      if (e.button !== undefined && e.button !== 0) return;
      measure();
      dragging = true;
      dragMoved = false;
      activePointerId = e.pointerId ?? null;
      startX = e.clientX;
      const m = new DOMMatrix(getComputedStyle(xAxisSwitchSlider).transform);
      base = m.m41 || 0;
      xAxisSwitchSlider.style.transition = 'none';
      try { if (activePointerId != null) xAxisSwitchSlider.setPointerCapture(activePointerId); } catch(_){}
      e.preventDefault?.();
    }
    function onPointerMove(e) {
      if (!dragging) return;
      const dx = e.clientX - startX;
      if (!dragMoved && Math.abs(dx) > 2) dragMoved = true;
      let x = base + dx;
      x = Math.max(0, Math.min(x, maxX));
      xAxisSwitchSlider.style.transform = `translateX(${x}px)`;
    }
    function finishDrag() {
      if (!dragging) return;
      dragging = false;
      try { if (activePointerId != null) xAxisSwitchSlider.releasePointerCapture(activePointerId); } catch(_){}
      activePointerId = null;
      const newType = nearestType();
      pos(newType, true);
      applyType(newType);
    }
    function cancelDrag() {
      if (!dragging) return;
      dragging = false;
      try { if (activePointerId != null) xAxisSwitchSlider.releasePointerCapture(activePointerId); } catch(_){}
      activePointerId = null;
      pos(currentXModeFromPayload(lastPayload), true);
    }

    xAxisSwitchTrack.addEventListener('click', () => {
      if (dragMoved) { dragMoved = false; return; }
      const curr = currentXModeFromPayload(lastPayload);
      const next = (curr === 'rpm') ? 'noise_db' : 'rpm';
      pos(next, true);
      applyType(next);
    });

    xAxisSwitchTrack.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove, { passive: true });
    window.addEventListener('pointerup', finishDrag, { passive: true });
    window.addEventListener('pointercancel', cancelDrag);
    window.addEventListener('blur', cancelDrag);

    measure();
    pos(currentXModeFromPayload(lastPayload), false);
    window.addEventListener('resize', () => {
      const keep = currentXModeFromPayload(lastPayload);
      measure();
      pos(keep, false);
    }, { passive:true });
  }

  function placeAxisOverlayAt(x, y, show){
    const overlay = ensureAxisOverlay();
    const off = window.__FS_TOGGLE_OFFSET || { x: 0, y: 0 };
    overlay.style.left = (x + (Number(off.x)||0)) + 'px';
    overlay.style.top  = (y + (Number(off.y)||0)) + 'px';
    overlay.style.visibility = show ? 'visible' : 'hidden';
    requestAnimationFrame(() => updateAxisSwitchPosition());
  }

  // 关键：render 也走 ECharts 就绪门闸
function render(payload){
  lastPayload = payload || lastPayload;
  if (!echartsReady || typeof window.echarts === 'undefined') {
    onEchartsReady(() => { render(lastPayload); });
    return;
  }
  if (!chart) init();

  const prevXMode = currentXModeFromPayload(lastPayload);
  const prevEmpty = !!(lastOption && lastOption.__empty);

  syncThemeAttr((lastPayload && lastPayload.theme) || 'light');

  // 新增：若用户已开启拟合，则同步安装 UI（非 idle）
  if (!fitUIInstalled && showFitCurves) {
    ensureFitUI();
    fitUIInstalled = true;
  } else if (!fitUIInstalled) {
    // 仍保留 idle 安装作为兜底
    onIdle(() => {
      if (!fitUIInstalled) {
        ensureFitUI();
        fitUIInstalled = true;
        toggleFitUI(showFitCurves && !layoutIsNarrow());
        placeFitUI();
        repaintPointer();
      }
    });
  }

  const option = buildOption(lastPayload);
  const nextXMode = currentXModeFromPayload(lastPayload);
  const nextEmpty = !!option.__empty;

  if (prevXMode !== nextXMode || prevEmpty !== nextEmpty) {
    try { chart.clear(); } catch(_) {}
  }

  chart.setOption(option, true);
  chart.resize();

  requestAnimationFrame(() => updateAxisSwitchPosition());
  if (option.__empty) {
    try { chart.dispatchAction({ type: 'updateAxisPointer', currTrigger: 'leave' }); } catch(_) {}
  }

  const { x, y, visible } = computePrefixCenter(option);
  placeAxisOverlayAt(x, y, visible && !option.__empty);

  lastOption = option;
  lastIsNarrow = layoutIsNarrow();

  toggleFitUI(showFitCurves && !layoutIsNarrow());
  placeFitUI();

  // 修改：等待 ECharts 真正完成绘制后再定位指针，避免 NaN
  try {
    const onFinished = () => {
      try { chart.off('finished', onFinished); } catch(_){}
      repaintPointer();
    };
    chart.on('finished', onFinished);
  } catch(_) {}
  // 再加一帧兜底
  requestAnimationFrame(() => repaintPointer());

  if (showFitCurves) refreshFitBubble();
}

  async function enterFullscreen(){
    const el = document.documentElement;
    try {
      await el.requestFullscreen();
      isFs = true;
      if (isMobile() && screen.orientation && screen.orientation.lock) {
        try { await screen.orientation.lock('landscape'); } catch(_) {}
      }
    } catch(err){
      console.warn('requestFullscreen 失败：', err);
    } finally {
      if (lastPayload) render(lastPayload); else if (chart) chart.resize();
    }
  }
  async function exitFullscreen(){
    try { if (document.fullscreenElement) await document.exitFullscreen(); }
    catch(err){ console.warn('exitFullscreen 失败：', err); }
    finally {
      isFs = false;
      if (lastPayload) render(lastPayload); else if (chart) chart.resize();
    }
  }
  function toggleFullscreen(){
    if (document.fullscreenElement) exitFullscreen(); else enterFullscreen();
  }

  function getExportBg() {
    const bg = getComputedStyle(document.body).backgroundColor;
    return bg && bg !== 'rgba(0, 0, 0, 0)' ? bg : '#ffffff';
  }

  function tokens(theme) {
    const dark = (theme||'').toLowerCase()==='dark';
    return {
      fontFamily:'system-ui,-apple-system,"Segoe UI","Helvetica Neue","Microsoft YaHei",Arial,sans-serif',
      axisLabel: dark ? '#d1d5db' : '#4b5563',
      axisName:  dark ? '#9ca3af' : '#6b7280',
      axisLine:  dark ? '#374151' : '#e5e7eb',
      gridLine:  dark ? 'rgba(255,255,255,0.10)' : 'rgba(0,0,0,0.08)',
      tooltipBg: dark ? 'var(--bg-bubble)' : 'rgba(255,255,255,0.98)',
      tooltipBorder: dark ? '#374151' : '#e5e7eb',
      tooltipText: dark ? '#f3f4f6' : '#1f2937',
      tooltipShadow: dark ? '0 6px 20px rgba(0,0,0,0.35)' : '0 6px 20px rgba(0,0,0,0.12)',
      pagerIcon: dark ? '#93c5fd' : '#2563eb'
    };
  }

  function currentXModeFromPayload(payload){
    const inPay = (payload?.chartData?.x_axis_type === 'noise_db' || payload?.chartData?.x_axis_type === 'noise') ? 'noise_db' : 'rpm';
    if (xAxisOverride) return xAxisOverride;
    return inPay;
  }

  const X_PLACEHOLDER_NEG = -1;
  const X_MIN_CLAMP = 0;

  function isFiniteNumber(v){ const n = Number(v); return Number.isFinite(n); }

  function buildSeries(rawSeries, xMode) {
    let maxAir = 0;
    let minX = +Infinity, maxX = -Infinity;

    const series = rawSeries.map(s => {
      const xSrc  = Array.isArray(s[xMode]) ? s[xMode] : [];
      const ySrc  = Array.isArray(s.airflow) ? s.airflow : [];
      const tipSrc = Array.isArray(xMode === 'rpm' ? s.noise_db : s.rpm)
        ? (xMode === 'rpm' ? s.noise_db : s.rpm) : [];

      const n = Math.min(xSrc.length, ySrc.length);
      const data = [];
      for (let i = 0; i < n; i++) {
        const xRaw = xSrc[i];
        const yRaw = ySrc[i];
        const yv = Number(yRaw);
        const xv = Number(xRaw);

        if (isFiniteNumber(yv)) {
          if (isFiniteNumber(xv) && xv !== X_PLACEHOLDER_NEG) {
            minX = Math.min(minX, xv);
            maxX = Math.max(maxX, xv);
            maxAir = Math.max(maxAir, yv);
            const tipRaw = tipSrc[i];
            const tip = isFiniteNumber(Number(tipRaw)) ? Number(tipRaw) : undefined;
            data.push({ value: [xv, yv], tip });
          } else {
            data.push({ value: [X_PLACEHOLDER_NEG, yv], tip: undefined, __missingX: true });
          }
        }
      }

      return {
        name: s.name,
        type: 'line',
        smooth: true,
        connectNulls: false,
        showSymbol: true,
        symbol: 'circle',
        symbolSize: 8,
        lineStyle: { width: 3, color: s.color },
        itemStyle: { color: s.color },
        label: { show: true, position: 'top', color: 'gray' },
        legendHoverLink: true,
        emphasis: {
          focus: 'series',
          blurScope: 'coordinateSystem',
          lineStyle: { width: 4 },
          itemStyle: { borderWidth: 1.2, shadowColor: 'rgba(0,0,0,0.25)', shadowBlur: 8 },
          label: { show: true }
        },
        blur: {
          lineStyle: { opacity: 0.18 },
          itemStyle: { opacity: 0.18 },
          label: { show: false }
        },
        data
      };
    });

    if (minX === +Infinity) { minX = 0; maxX = 100; }
    if (maxAir <= 0) maxAir = 100;

    const span = Math.max(1, maxX - minX);
    const pad = Math.floor(span * 0.2);
    return { series, xMin: Math.max(minX - pad, 0), xMax: maxX + pad, yMax: Math.ceil(maxAir * 1.4) };
  }

  function buildOption(payload) {
    const { chartData, theme } = payload || {};
    const t = tokens(theme||'light');
    const sList = Array.isArray(chartData?.series) ? chartData.series : [];
    const xMode = currentXModeFromPayload(payload);

    let isNarrow = chart && typeof chart.getWidth === 'function'
      ? (chart.getWidth() < 600)
      : (typeof window !== 'undefined' ? window.innerWidth < 600 : false);
    if (isFs && isMobile()) isNarrow = false;
    if (isNarrow) { if (!showRawCurves) showRawCurves = true; if (showFitCurves) showFitCurves = false; }

    const exportBg = (payload && payload.chartBg) || getExportBg();
    const bgNormal = isFs ? exportBg : 'transparent';

    if (!sList.length || (!showRawCurves && !showFitCurves)) {
      toggleFitUI(false);
      return {
        __empty:true,
        backgroundColor: bgNormal,
        title:{ text:'暂无数据', left:'center', top:'middle',
          textStyle:{ color:t.axisLabel, fontFamily:t.fontFamily } },
        toolbox:{ feature:{ saveAsImage:{ backgroundColor:exportBg, pixelRatio: window.devicePixelRatio || 1 } } },
        tooltip:{ show:false, triggerOn:'none' }
      };
    }

    const built = buildSeries(sList, xMode);

    const xName = xMode==='rpm' ? '转速(RPM)' : '噪音(dB)';
    const titlePrefix = xMode==='rpm' ? '转速' : '噪音';
    const titleTop = 10, titleFontSize = 20, titleFontWeight = 600;
    const titleText = `${titlePrefix}${TITLE_GLUE}风量曲线`;
    const titleMeasure = measureText(titleText, titleFontSize, titleFontWeight, t.fontFamily);
    const gridTop = Math.max(54, titleTop + Math.ceil(titleMeasure.height) + 12);

    const legendMeta = {};
    sList.forEach(s=>{
      const brand = s.brand || s.brand_name_zh || s.brand_name || '';
      const model = s.model || s.model_name || '';
      const rt    = s.res_type || s.resistance_type_zh || s.resistance_type || s.rt || '';
      const rl    = s.res_loc || s.resistance_location_zh || s.resistance_location || s.rl || '';
      const key   = s.name || [brand, model].filter(Boolean).join(' ') || String(s.key || '');
      legendMeta[key] = { brand, model, rt, rl };
    });
    function desktopLegendFormatter(name){
      const m = legendMeta[name] || {};
      const line1 = [m.brand, m.model].filter(Boolean).join(' ');
      const line2 = [m.rt, m.rl].filter(Boolean).join(' ');
      if (line2) return `{l1|${line1}}\n{l2|${line2}}`;
      return `{l1|${line1||name}}`;
    }
    function mobileLegendFormatter(name){
      const m = legendMeta[name] || {};
      const left = [m.brand, m.model].filter(Boolean).join(' ');
      const right = [m.rt, m.rl].filter(Boolean).join(' ');
      if (right) return `{m1|${left}} {m1|-} {m2|${right}}`;
      return `{m1|${left||name}}`;
    }

    const isN = isNarrow;
    const legendCfg = isN ? {
      type: 'scroll',
      orient: 'vertical',
      left: 20, right: 6, bottom: 6,
      itemWidth: 16, itemHeight: 10, align: 'auto',
      pageIconColor: t.pagerIcon, pageTextStyle: { color: t.axisLabel },
      textStyle: { color: t.axisLabel, fontFamily: t.fontFamily,
        rich: { m1:{ fontSize:13,fontWeight:600,color:t.axisLabel,lineHeight:18 },
                m2:{ fontSize:11,fontWeight:500,color:t.axisName,lineHeight:16 } } },
      formatter: mobileLegendFormatter
    } : {
      type: 'scroll',
      orient: 'vertical',
      right: 80, top: gridTop, bottom: 10,
      itemWidth: 18, itemHeight: 10, itemGap: 16, align: 'auto',
      pageIconColor: t.pagerIcon, pageTextStyle: { color: t.axisLabel },
      textStyle: { color: t.axisLabel, fontFamily: t.fontFamily,
        rich: { l1:{ fontSize:13,fontWeight:600,color:t.axisLabel,lineHeight:18 },
                l2:{ fontSize:11,fontWeight:500,color:t.axisName,lineHeight:14 } } },
      formatter: desktopLegendFormatter
    };
    legendCfg.data = sList.map(s => s.name);
    try {
      const prevSel = chart && chart.getOption && chart.getOption().legend && chart.getOption().legend[0] && chart.getOption().legend[0].selected;
      if (prevSel) legendCfg.selected = prevSel;
    } catch(_){}

    const finalSeries = [];
    if (showRawCurves) {
      built.series.forEach(s => finalSeries.push(s));
    }

    if (showFitCurves) {
      ensureFitModels(sList, xMode);
      const width = Math.max(300, chart.getWidth ? chart.getWidth() : 800);
      const sampleCount = computeSampleCount(width);
      sList.forEach(s => {
        const model = fitModelsCache[xMode].get(s.name);
        if (!model || model.x0 == null || model.x1 == null) return;
        const sMin = Math.min(model.x0, model.x1);
        const sMax = Math.max(model.x0, model.x1);
        const xmin = Math.max(built.xMin, sMin);
        const xmax = Math.min(built.xMax, sMax);
        if (!(xmax > xmin)) return;

        const pts = resampleSingle(model, xmin, xmax, sampleCount);
        finalSeries.push({
          id: `fit-line:${xMode}:${s.name}`,
          name: s.name,
          type: 'line',
          smooth: false,
          showSymbol: false,
          connectNulls: false,
          data: pts.map(p => [p.x, p.y]),
          lineStyle: { width: 2.5, type:'dashed', color: s.color, opacity: 0.95 },
          itemStyle: { color: s.color },
          legendHoverLink: true,
          emphasis: { focus: 'series', blurScope: 'coordinateSystem', lineStyle: { width: 3.5, opacity: 1 }, itemStyle: { opacity: 1 } },
          blur: { lineStyle: { opacity: 0.2 }, itemStyle: { opacity: 0.2 } },
          silent: false,
          tooltip: { show: false },
          z: 3
        });
      });
    }

    const rawMin = Math.max(X_MIN_CLAMP, built.xMin);
    const rawMax = built.xMax * 1.2;
    let xMinForAxis = Math.floor(rawMin);
    let xMaxForAxis = Math.ceil(rawMax);
    if (!(xMaxForAxis > xMinForAxis)) xMaxForAxis = xMinForAxis + 1;

    const toolboxFeatures = isNarrow ? {
      restore: {},
      saveAsImage: { backgroundColor: exportBg, pixelRatio: window.devicePixelRatio || 1 },
      myFullscreen: {
        show: true,
        title: !!document.fullscreenElement ? '退出全屏' : '全屏查看',
        icon: !!document.fullscreenElement
          ? 'path://M3 7v7h7M3 14l7-7M21 17v-7h-7M21 10l-7 7'
          : 'path://M3 10v-7h7M3 3l7 7M21 14v7h-7M21 21l-7-7',
        onclick: () => toggleFullscreen()
      }
    } : {
      dataZoom: { yAxisIndex: 'none' },
      restore: {},
      saveAsImage: { backgroundColor: exportBg, pixelRatio: window.devicePixelRatio || 1 },
      myFullscreen: {
        show: true,
        title: !!document.fullscreenElement ? '退出全屏' : '全屏查看',
        icon: !!document.fullscreenElement
          ? 'path://M3 7v7h7M3 14l7-7M21 17v-7h-7M21 10l-7 7'
          : 'path://M3 10v-7h7M3 3l7 7M21 14v7h-7M21 21l-7-7',
        onclick: () => toggleFullscreen()
      }
    };

    return {
      __empty:false,
      __titlePrefix:titlePrefix,

      backgroundColor: bgNormal,
      color: sList.map(s=>s.color),
      textStyle:{ fontFamily:t.fontFamily },
      stateAnimation: { duration: 220, easing: 'cubicOut' },

      grid:{ left:40, right: (isN ? 20 : 260), top: gridTop, bottom: (isN ? Math.min(320, 50 + (sList.length || 1) * 22) : 40) },

      title: {
        text: titleText,
        left: 'center',
        top: titleTop,
        textStyle: { color: t.axisLabel, fontSize: 20, fontWeight: 600, fontFamily: t.fontFamily }
      },

      legend: legendCfg,

      xAxis:{
        type:'value', name:xName, nameLocation:'middle', nameGap:25, nameMoveOverlap:true,
        nameTextStyle:{ color:t.axisName, fontWeight:600, fontFamily:t.fontFamily, textShadowColor:'rgba(0,0,0,0.28)', textShadowBlur:4, textShadowOffsetY:1 },
        axisLabel:{ color:t.axisLabel, fontSize:12, fontFamily:t.fontFamily, margin:10 },
        axisLine:{ lineStyle:{ color:t.axisLine }},
        splitLine:{ show:true, lineStyle:{ color:t.gridLine }},
        min: xMinForAxis,
        max: xMaxForAxis
      },
      yAxis:{
        type:'value', name:'风量(CFM)', min:0, max: built.yMax * 1.3,
        nameTextStyle:{ color:t.axisName, fontWeight:600, textShadowColor:'rgba(0,0,0,0.28)', textShadowBlur:4, textShadowOffsetY:1 },
        axisLabel:{ color:t.axisLabel }, axisLine:{ lineStyle:{ color:t.axisLine }},
        splitLine:{ show:true, lineStyle:{ color:t.gridLine }}
      },

      tooltip:{
        appendToBody: true,
        axisPointer: { type: "cross", label: { color: t.tooltipText } },
        trigger:'item',
        backgroundColor:t.tooltipBg,
        borderColor:t.tooltipBorder,
        borderWidth: 1,
        borderRadius: 12,
        textStyle:{ color:t.tooltipText },
        extraCssText: `
          backdrop-filter: blur(4px) saturate(120%);
          -webkit-backdrop-filter: blur(4px) saturate(120%);
          box-shadow: ${t.tooltipShadow};
          z-index: 1000000;
        `,
        formatter:function(p){
          const xModeNow = currentXModeFromPayload(lastPayload);
          const xLabel = xModeNow==='rpm' ? 'RPM, ' : 'dB, ';
          const infoLabel = xModeNow==='rpm' ? 'dB' : 'RPM';
          const x = p.value?.[0], y = p.value?.[1];
          const tip = p.data?.tip ?? '';
          const dot = `<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${p.color};margin-right:4px;"></span>`;
          return `${dot}${p.seriesName}<br/>&nbsp;&nbsp;&nbsp;&nbsp;${y}CFM @${x}${xLabel}${tip}${infoLabel}`;
        }
      },

      toolbox:{
        top: -5, right: 0,
        feature:toolboxFeatures
      },

      dataZoom: [
        { type: 'inside', xAxisIndex: 0, throttle: 50, zoomOnMouseWheel: true, moveOnMouseWheel: true, moveOnMouseMove: true ,filterMode: "none", startValue: xMinForAxis, endValue: xMaxForAxis*0.85 },
        { type: 'inside', yAxisIndex: 0, throttle: 50, zoomOnMouseWheel: 'alt', moveOnMouseWheel: 'alt', moveOnMouseMove: true ,filterMode: "none", endValue: built.yMax}
      ],

      series: finalSeries
    };
  }

  function measureText(text, size, weight, family){
    const ctx = __textMeasureCtx;
    ctx.font = `${String(weight||400)} ${Number(size||14)}px ${family||'sans-serif'}`;
    const m = ctx.measureText(text || '');
    const width = m.width || 0;
    const ascent = (typeof m.actualBoundingBoxAscent === 'number') ? m.actualBoundingBoxAscent : size * 0.8;
    const descent = (typeof m.actualBoundingBoxDescent === 'number') ? m.actualBoundingBoxDescent : size * 0.2;
    return { width, height: ascent + descent };
  }

  function computePrefixCenter(option){
    if (!chart || !option || !option.title) return { x: 0, y: 0, visible:false };
    if (option.__empty) return { x: 0, y: 0, visible:false };
    const title = option.title;
    const ts = title.textStyle || {};
    const size = Number(ts.fontSize || option.__titleFontSize || 14);
    const weight = ts.fontWeight || option.__titleFontWeight || 600;
    const family = ts.fontFamily || option.__titleFamily;
    const prefix = String(option.__titlePrefix || '');
    const totalText = `${prefix}${TITLE_GLUE}风量曲线`;

    const mTotal = measureText(totalText, size, weight, family);
    const mPrefix = measureText(prefix, size, weight, family);
    const chartW = chart.getWidth();
    const centerX = chartW / 2;
    const totalLeft = centerX - mTotal.width / 2;
    const prefixCenterX = totalLeft + mPrefix.width / 2;
    const top = (typeof title.top === 'number') ? title.top : 0;
    const centerY = top + (mTotal.height / 2);
    return { x: Math.round(prefixCenterX), y: Math.round(centerY), visible:true };
  }

  function syncThemeAttr(theme){
    const t = String(theme || 'light').toLowerCase();
    document.documentElement.setAttribute('data-theme', t);
    document.body.setAttribute('data-theme', t);
  }

  function pxToDataX(xPixel){
    try { return chart.convertFromPixel({ xAxisIndex: 0 }, xPixel); } catch(e){ return NaN; }
  }
  function dataToPxX(xData){
    try { return chart.convertToPixel({ xAxisIndex: 0 }, xData); } catch(e){ return NaN; }
  }

  function ensureNarrowHint(){
    const root = document.getElementById('chart');
    let hint = document.getElementById('narrowHint');
    if (!hint){
      hint = document.createElement('div');
      hint.id = 'narrowHint';
      hint.className = 'fit-narrow-hint';
      hint.textContent = `${FIT_ALGO_NAME}曲线请在图表右上角切换至全屏模式`;
      root.appendChild(hint);
    }
    return hint;
  }

  function ensureFitUI(){
    const root = document.getElementById('chart');

    let btns = document.getElementById('fitButtons');
    if (!btns){
      btns = document.createElement('div');
      btns.id = 'fitButtons';
      btns.className = 'fit-buttons';
      btns.innerHTML = `
        <button class="btn" id="btnRaw">ECHARTS<br>曲线</button>
        <button class="btn" id="btnFit">${FIT_ALGO_NAME}<br>曲线</button>
      `;
      root.appendChild(btns);
      const btnRaw = btns.querySelector('#btnRaw');
      const btnFit = btns.querySelector('#btnFit');
      function syncButtons(){
        btnRaw.classList.toggle('active', showRawCurves);
        btnFit.classList.toggle('active', showFitCurves);
      }
      function ensureAtLeastOne(onWhich){
        if (!showRawCurves && !showFitCurves){
          if (onWhich === 'raw') showFitCurves = true; else showRawCurves = true;
        }
      }
      btnRaw.addEventListener('click', ()=>{
        showRawCurves = !showRawCurves;
        ensureAtLeastOne('raw');
        syncButtons();
        if (lastPayload) render(lastPayload);
      });
      btnFit.addEventListener('click', ()=>{
        showFitCurves = !showFitCurves;
        ensureAtLeastOne('fit');
        syncButtons();
        if (lastPayload) render(lastPayload);
      });
      syncButtons();
    }

    let bubble = document.getElementById('fitBubble');
    if (!bubble){
      bubble = document.createElement('div');
      bubble.id = 'fitBubble';
      bubble.className = 'fit-bubble';
      bubble.innerHTML = `
        <div class="head">
          <div class="title">${FIT_ALGO_NAME} 估算值</div>
          <div class="x-input">
            <span>当前位置</span>
            <input id="fitXInput" type="number" step="1" />
            <span id="fitXUnit"></span>
          </div>
        </div>
        <div id="fitBubbleRows"></div>
        <div class="hint">按系列可见性（Legend）过滤，按风量从大到小排序</div>
      `;
      root.appendChild(bubble);

      bindBubbleDrag(bubble);

      const xInput = bubble.querySelector('#fitXInput');
      xInput.addEventListener('input', onBubbleInputLive);
      xInput.addEventListener('change', onBubbleInputCommit);
      xInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') { onBubbleInputCommit(); } });
    }

    let ptr = document.getElementById('fitPointer');
    if (!ptr){
      ptr = document.createElement('div');
      ptr.id = 'fitPointer';
      ptr.className = 'fit-pointer';
      ptr.innerHTML = `
        <div class="line"></div>
        <div class="handle" id="fitPointerHandle"></div>
      `;
      root.appendChild(ptr);
      bindPointerDrag();
    }
  }

  function bindBubbleDrag(bubble){
    if (!bubble) return;

    let activePointerId = null;
    let startX = 0, startY = 0;
    let baseLeft = 0, baseTop = 0;
    let dragging = false;
    const DRAG_THRESHOLD = 4;

    function isInteractiveTarget(el){
      return !!(el && (el.closest('input, textarea, select, button, [contenteditable=""], [contenteditable="true"]')));
    }
    function onPointerDown(e){
      if (e.button !== undefined && e.button !== 0) return;
      if (isInteractiveTarget(e.target)) return;

      const rect = bubble.getBoundingClientRect();
      startX   = e.clientX; startY   = e.clientY;
      baseLeft = rect.left; baseTop  = rect.top;
      dragging = false;

      activePointerId = e.pointerId ?? null;
      try { if (activePointerId != null) bubble.setPointerCapture(activePointerId); } catch(_){}
    }
    function onPointerMove(e){
      if (activePointerId != null && (e.pointerId ?? null) !== activePointerId) return;
      if (activePointerId == null) return;

      const dx = e.clientX - startX;
      const dy = e.clientY - startY;

      if (!dragging && Math.hypot(dx, dy) > DRAG_THRESHOLD){
        dragging = true;
        bubble.classList.add('dragging');
      }
      if (!dragging) return;

      const bw = bubble.offsetWidth  || 0;
      const bh = bubble.offsetHeight || 0;
      const vw = window.innerWidth   || document.documentElement.clientWidth  || 0;
      const vh = window.innerHeight  || document.documentElement.clientHeight || 0;

      let newLeft = Math.min(Math.max(0, baseLeft + dx), Math.max(0, vw - bw));
      let newTop  = Math.min(Math.max(0, baseTop  + dy), Math.max(0, vh - bh));

      bubble.style.left = Math.round(newLeft) + 'px';
      bubble.style.top  = Math.round(newTop)  + 'px';
      bubble.style.right  = 'auto';
      bubble.style.bottom = 'auto';

      bubblePos.left = newLeft;
      bubblePos.top  = newTop;
      bubbleUserMoved = true;
    }
    function endDrag(){
      if (activePointerId == null) return;
      try { bubble.releasePointerCapture(activePointerId); } catch(_){}
      activePointerId = null; dragging = false; bubble.classList.remove('dragging');
    }

    bubble.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove, { passive:true });
    window.addEventListener('pointerup',   endDrag,       { passive:true  });
    window.addEventListener('pointercancel', endDrag,     { passive:true  });
    window.addEventListener('blur', endDrag);
  }

  function toggleFitUI(showFit){
    const btns = document.getElementById('fitButtons');
    const bubble = document.getElementById('fitBubble');
    const ptr = document.getElementById('fitPointer');
    const narrow = layoutIsNarrow();
    const empty  = !lastOption || lastOption.__empty;

    if (btns) btns.style.visibility = (empty || narrow) ? 'hidden' : 'visible';

    const showFloating = showFit && !narrow && !empty;
    if (bubble) bubble.style.visibility = showFloating ? 'visible' : 'hidden';
    if (ptr)    ptr.style.visibility    = showFloating ? 'visible' : 'hidden';
  }

  function placeFitUI(){
    const btns = document.getElementById('fitButtons');
    const bubble = document.getElementById('fitBubble');
    if (!lastOption) return;

    const grid = lastOption.grid || { left:40, right: 260, top: 60, bottom: 40 };
    const chartW = chart ? chart.getWidth() : 800;
    const chartH = chart ? chart.getHeight() : 600;
    const left = (typeof grid.left==='number') ? grid.left : 40;
    const rightGap = (typeof grid.right==='number') ? grid.right : 260;
    const top = (typeof grid.top==='number') ? grid.top : 60;
    const bottomGap = (typeof grid.bottom==='number') ? grid.bottom : 40;

    const pad = 6;

    if (btns){
      btns.style.right = '20px';
      btns.style.bottom = '20px';
      btns.style.visibility = (lastOption.__empty || layoutIsNarrow()) ? 'hidden' : 'visible';
    }

    if (bubble){
      bubble.style.position = 'fixed';

      const bw2 = bubble.offsetWidth  || 0;
      const bh2 = bubble.offsetHeight || 0;

      if (!bubbleUserMoved){
        const preferredX = left + 2;
        const preferredY = top  + 2;
        const vw = window.innerWidth  || document.documentElement.clientWidth  || chartW;
        const vh = window.innerHeight || document.documentElement.clientHeight || chartH;
        const bx = Math.min(Math.max(pad, preferredX), Math.max(pad, vw - bw2 - pad));
        const by = Math.min(Math.max(pad, preferredY), Math.max(pad, vh - bh2 - pad));
        bubble.style.left = bx + 'px';
        bubble.style.top  = by + 'px';
        bubble.style.right  = 'auto';
        bubble.style.bottom = 'auto';
        bubblePos.left = bx; bubblePos.top = by;
      } else {
        const vw = window.innerWidth  || document.documentElement.clientWidth  || chartW;
        const vh = window.innerHeight || document.documentElement.clientHeight || chartH;
        const bx = Math.min(Math.max(pad, bubblePos.left || 0), Math.max(pad, vw - bw2 - pad));
        const by = Math.min(Math.max(pad, bubblePos.top  || 0), Math.max(pad, vh - bh2 - pad));
        bubble.style.left = Math.round(bx) + 'px';
        bubble.style.top  = Math.round(by) + 'px';
        bubble.style.right  = 'auto';
        bubble.style.bottom = 'auto';
        bubblePos.left = bx; bubblePos.top = by;
      }

      bubble.style.visibility = (showFitCurves && !lastOption.__empty) ? 'visible' : 'hidden';

      const unit = (currentXModeFromPayload(lastPayload) === 'rpm') ? 'RPM' : 'dB';
      const unitSpan = bubble.querySelector('#fitXUnit');
      if (unitSpan) unitSpan.textContent = unit;
    }

    const hint = ensureNarrowHint();
    const narrow = layoutIsNarrow();
    if (narrow && !lastOption.__empty) {
      const x = chartW - rightGap - (hint.offsetWidth || 0) - 6;
      const y = chartH - bottomGap - 14;
      hint.style.left = Math.max(2, x) + 'px';
      hint.style.top  = Math.max(2, y) + 'px';
      hint.style.visibility = 'visible';
    } else {
      hint.style.visibility = 'hidden';
    }
  }

  function bindPointerDrag(){
    const handle = document.getElementById('fitPointerHandle');
    if (!handle) return;

    let dragging=false, startX=0, baseX=0, activePointerId=null;

    function measureGrid(){
      if (!lastOption) return { left:40, right: (chart ? chart.getWidth() - 260 : 800), top: 60, height: 300 };
      const grid = lastOption.grid || { left:40, right: 260, top: 60, bottom: 40 };
      const chartW = chart ? chart.getWidth() : 800;
      const chartH = chart ? chart.getHeight() : 600;
      const left = (typeof grid.left==='number') ? grid.left : 40;
      const rightGap = (typeof grid.right==='number') ? grid.right : 260;
      const top = (typeof grid.top==='number') ? grid.top : 60;
      const bottomGap = (typeof grid.bottom==='number') ? grid.bottom : 40;
      const right = chartW - rightGap;
      const height = chartH - top - bottomGap;
      return { left, right, top, height };
    }

    function onDown(e){
      if (e.button !== undefined && e.button !== 0) return;
      dragging = true;
      activePointerId = e.pointerId ?? null;
      startX = e.clientX;
      const ptr = document.getElementById('fitPointer');
      baseX = parseFloat(ptr?.style.left || '0');
      handle.style.cursor = 'grabbing';
      try { if (activePointerId != null) handle.setPointerCapture(activePointerId); } catch(_){}
      e.preventDefault?.();
    }
    function onMove(e){
      if (!dragging) return;
      const grid = measureGrid();
      const dx = e.clientX - startX;
      let x = baseX + dx;
      x = Math.max(grid.left, Math.min(x, grid.right));
      const ptr = document.getElementById('fitPointer');
      ptr.style.left = x + 'px';

      const xVal = pxToDataX(x);
      const mode = currentXModeFromPayload(lastPayload);
      if (Number.isFinite(xVal)) {
        xQueryByMode[mode] = clampXDomain(xVal);
        syncBubbleInput();
        if (showFitCurves) refreshFitBubble();
      }
    }
    function onUp(){
      if (!dragging) return;
      dragging=false;
      handle.style.cursor = 'grab';
      try { if (activePointerId != null) handle.releasePointerCapture(activePointerId); } catch(_){}
      activePointerId=null;
    }
    function onCancel(){
      if (!dragging) return;
      dragging=false;
      handle.style.cursor = 'grab';
      try { if (activePointerId != null) handle.releasePointerCapture(activePointerId); } catch(_){}
      activePointerId=null;
    }

    handle.addEventListener('pointerdown', onDown);
    window.addEventListener('pointermove', onMove, { passive:true });
    window.addEventListener('pointerup', onUp, { passive:true });
    window.addEventListener('pointercancel', onCancel);
    window.addEventListener('blur', onCancel);
  }

  function repaintPointer(){
    const ptr = document.getElementById('fitPointer');
    if (!ptr || !lastOption) return;
    if (!showFitCurves || lastOption.__empty) { ptr.style.visibility = 'hidden'; return; }

    const grid = lastOption.grid || { left:40, right: 260, top: 60, bottom: 40 };
    const chartW = chart ? chart.getWidth() : 800;
    const chartH = chart ? chart.getHeight() : 600;
    const left = (typeof grid.left==='number') ? grid.left : 40;
    const rightGap = (typeof grid.right==='number') ? grid.right : 260;
    const top = (typeof grid.top==='number') ? grid.top : 60;
    const bottomGap = (typeof grid.bottom==='number') ? grid.bottom : 40;
    const height = chartH - top - bottomGap;

    const mode = currentXModeFromPayload(lastPayload);
    if (xQueryByMode[mode] == null) {
      const [vx0, vx1] = getVisibleXRange();
      xQueryByMode[mode] = (vx0 + vx1) / 2;
    }
    clampXQueryIntoVisibleRange();

    const xPixel = dataToPxX(xQueryByMode[mode]);
    if (!Number.isFinite(xPixel)) { ptr.style.visibility = 'hidden'; return; }

    ptr.style.left = xPixel + 'px';
    ptr.style.top = top + 'px';
    ptr.style.height = height + 'px';
    ptr.style.visibility = 'visible';

    syncBubbleInput();
    if (showFitCurves) refreshFitBubble();
  }

  function syncBubbleInput(){
    const inp = document.getElementById('fitXInput');
    if (!inp) return;
    const mode = currentXModeFromPayload(lastPayload);
    const val = Number(xQueryByMode[mode]);
    const rounded = (mode === 'noise_db') ? Number(val.toFixed(1)) : Math.round(val);
    inp.value = String(rounded);

    const [vx0, vx1] = getVisibleXRange();
    inp.setAttribute('min', String(Math.floor(vx0)));
    inp.setAttribute('max', String(Math.ceil(vx1)));
    inp.setAttribute('step', (mode === 'noise_db') ? '0.1' : '1');
  }

  function onBubbleInputLive(){
    const inp = document.getElementById('fitXInput');
    if (!inp) return;
    const mode = currentXModeFromPayload(lastPayload);
    const raw = Number(inp.value);
    if (!Number.isFinite(raw)) return;
    xQueryByMode[mode] = clampXDomain(raw);
    clampXQueryIntoVisibleRange();

    const xPixel = dataToPxX(xQueryByMode[mode]);
    const ptr = document.getElementById('fitPointer');
    if (ptr && Number.isFinite(xPixel)) ptr.style.left = xPixel + 'px';

    if (showFitCurves) refreshFitBubble();
  }
  function onBubbleInputCommit(){
    repaintPointer();
    refreshFitBubble();
  }

  function refreshFitBubble(){
    const bubble = document.getElementById('fitBubble');
    if (!bubble || !showFitCurves || !lastPayload || !chart) return;
    const rowsEl = bubble.querySelector('#fitBubbleRows');
    const mode = currentXModeFromPayload(lastPayload);
    const x = xQueryByMode[mode];
    if (x == null) return;

    const sList = Array.isArray(lastPayload?.chartData?.series) ? lastPayload.chartData.series : [];
    ensureFitModels(sList, mode);

    const opt = chart.getOption() || {};
    const selMap = (opt.legend && opt.legend[0] && opt.legend[0].selected) || {};
    const items = [];
    sList.forEach(s => {
      const visible = (selMap[s.name] !== false);
      if (!visible) return;
      const model = fitModelsCache[mode].get(s.name);
      if (!model) return;

      const dom0 = Math.min(model.x0, model.x1);
      const dom1 = Math.max(model.x0, model.x1);
      let y = NaN;
      if (x >= dom0 && x <= dom1) {
        y = evalPchipJS(model, x);
      }
      items.push({ name: s.name, color: s.color, y });
    });

    const fmt = (v)=> Math.round(v);
    const withVal = items.filter(it => Number.isFinite(it.y)).sort((a,b)=> b.y - a.y);
    const noVal   = items.filter(it => !Number.isFinite(it.y));

    const base = (withVal.length && withVal[0].y > 0) ? withVal[0].y : 0;
    const pctVal = (v)=> (Number.isFinite(v) && base > 0) ? Math.round((v / base) * 100) : null;

    const valTexts = items.map(it => Number.isFinite(it.y) ? `${fmt(it.y)} CFM` : '-');
    const maxValChars = valTexts.reduce((m,s)=>Math.max(m, s.length), 1);
    const pctWidthCh = 6;

    const ordered = withVal.concat(noVal);
    rowsEl.innerHTML = ordered.map(it => {
      const has = Number.isFinite(it.y);
      const valText = has ? `${fmt(it.y)} CFM` : '-';
      const pct = has ? pctVal(it.y) : null;
      const pctText = (pct==null) ? '-' : `(${pct}%)`;
      return `
        <div class="row">
          <span class="dot" style="background:${it.color}"></span>
          <span>${it.name}</span>
          <span style="margin-left:auto; display:inline-flex; align-items:center; gap:8px;">
            <span style="min-width:${maxValChars}ch; text-align:right; font-weight:800; font-variant-numeric:tabular-nums;">${valText}</span>
            <span style="width:${pctWidthCh}ch; text-align:right; font-variant-numeric:tabular-nums;">${pctText}</span>
          </span>
        </div>
      `;
    }).join('');
  }

  function ensureFitModels(sList, xMode){
    const models = fitModelsCache[xMode];
    sList.forEach(s => {
      const ph = s && s.pchip ? (xMode === 'noise_db' ? s.pchip.noise_db : s.pchip.rpm) : null;
      if (ph && Array.isArray(ph.x) && Array.isArray(ph.y) && Array.isArray(ph.m) && ph.x0 != null && ph.x1 != null) {
        models.set(s.name, ph);
      } else {
        models.delete(s.name);
      }
    });
  }

  function evalPchipJS(model, x){
    if (!model || !Array.isArray(model.x) || !Array.isArray(model.y) || !Array.isArray(model.m)) return NaN;
    const xs = model.x, ys = model.y, ms = model.m;
    const n = xs.length;
    if (n === 0) return NaN;
    if (n === 1) return ys[0];

    let xv = x;
    if (xv <= xs[0]) xv = xs[0];
    if (xv >= xs[n - 1]) xv = xs[n - 1];

    let lo = 0, hi = n - 2, i = 0;
    while (lo <= hi) {
      const mid = (lo + hi) >> 1;
      if (xs[mid] <= xv && xv <= xs[mid + 1]) { i = mid; break; }
      if (xv < xs[mid]) hi = mid - 1; else lo = mid + 1;
    }
    if (lo > hi) i = Math.max(0, Math.min(n - 2, lo));

    const x0 = xs[i], x1 = xs[i + 1];
    const h = (x1 - x0) || 1;
    const t = (xv - x0) / h;
    const y0 = ys[i], y1 = ys[i + 1];
    const m0 = ms[i] * h, m1 = ms[i + 1] * h;

    const h00 = (2 * t*t*t - 3 * t*t + 1);
    const h10 = (t*t*t - 2 * t*t + t);
    const h01 = (-2 * t*t*t + 3 * t*t);
    const h11 = (t*t*t - t*t);
    return h00 * y0 + h10 * m0 + h01 * y1 + h11 * m1;
  }

  function computeSampleCount(widthPx){
    const n = Math.round(widthPx / 1.5);
    return Math.max(200, Math.min(1200, n));
  }

  function resampleSingle(model, xmin, xmax, count){
    const n = Math.max(2, (count|0));
    const pts = [];
    const dom0 = Math.min(model.x0, model.x1);
    const dom1 = Math.max(model.x0, model.x1);
    const x0 = Math.max(xmin, dom0);
    const x1 = Math.min(xmax, dom1);
    if (!(x1 > x0)) return pts;
    for (let i = 0; i < n; i++){
      const t = (n === 1) ? 0 : (i / (n - 1));
      const x = x0 + (x1 - x0) * t;
      const y = evalPchipJS(model, x);
      pts.push({ x, y: Number.isFinite(y) ? y : NaN });
    }
    return pts;
  }

  function clampXDomain(val){
    if (!lastOption) return val;
    const xAxis = lastOption.xAxis || {};
    const xmin = Number(xAxis.min); const xmax = Number(xAxis.max);
    if (!Number.isFinite(xmin) || !Number.isFinite(xmax)) return val;
    return Math.max(xmin, Math.min(val, xmax));
  }

  function getVisibleXRange(){
    if (!lastOption) return [0,1];
    const xAxis = lastOption.xAxis || {};
    const xmin = Number(xAxis.min); const xmax = Number(xAxis.max);
    let vmin = xmin, vmax = xmax;
    const opt = chart.getOption() || {};
    const dz = (opt.dataZoom||[]).find(z => z.xAxisIndex === 0 || (z.xAxisIndex||0)===0) || null;
    if (dz && typeof dz.start === 'number' && typeof dz.end === 'number') {
      const span = xmax - xmin;
      vmin = xmin + span * (dz.start/100);
      vmax = xmin + span * (dz.end/100);
    }
    return [vmin, vmax];
  }

  function clampXQueryIntoVisibleRange(){
    const mode = currentXModeFromPayload(lastPayload);
    if (xQueryByMode[mode] == null) return;
    const [vmin, vmax] = getVisibleXRange();
    if (xQueryByMode[mode] < vmin) xQueryByMode[mode] = vmin;
    if (xQueryByMode[mode] > vmax) xQueryByMode[mode] = vmax;
  }

  // 父页通信：未就绪时排队等待
  window.addEventListener('message', (e)=>{
    if (e.origin !== window.location.origin) return;
    const { type, payload } = e.data || {};
    if (type==='chart:update' && payload) {
      lastPayload = payload;
      if (!echartsReady || typeof window.echarts === 'undefined') {
        onEchartsReady(() => render(lastPayload));
      } else {
        render(payload);
      }
    }
    if (type==='chart:resize') {
      const kick = () => {
        if (!chart) return;
        const nowNarrow = layoutIsNarrow();
        if (lastIsNarrow === null) lastIsNarrow = nowNarrow;

        if (nowNarrow !== lastIsNarrow) {
          lastIsNarrow = nowNarrow;
          if (lastPayload) render(lastPayload);
          else chart.resize();
        } else {
          chart.resize();
          if (lastOption) {
            const { x, y, visible } = computePrefixCenter(lastOption);
            placeAxisOverlayAt(x, y, visible && !lastOption.__empty);
            placeFitUI();
            repaintPointer();
          }
        }
      };
      if (!echartsReady || typeof window.echarts === 'undefined') onEchartsReady(kick); else kick();
    }
  }, { passive:true });

  // DOM 就绪后，若已经有 payload 并且 echarts 就绪，触发一次渲染
  document.addEventListener('DOMContentLoaded', () => {
    if (lastPayload) {
      if (!echartsReady) onEchartsReady(() => render(lastPayload));
      else render(lastPayload);
    } else {
      // NEW: 主动向父页要数据，避免父页早发消息导致丢失
      ensurePayloadHandshake();
      if (echartsReady) {
        // 若 ECharts 已就绪但还没 payload，也再请求一次
        ensurePayloadHandshake();
      } else {
        onEchartsReady(() => ensurePayloadHandshake());
      }
    }
  }, { once:true });

  let __chartRO = null;
  function installChartResizeObserver(){
    if (__chartRO) return;
    const el = document.getElementById('chart');
    if (!el) return;
    __chartRO = new ResizeObserver(entries => {
      for (const entry of entries) {
        const cr = entry.contentRect || {};
        if (chart && cr.width > 0 && cr.height > 0) {
          try { chart.resize(); } catch(_) {}
          // 同步依赖尺寸的浮层与指针
          try { placeFitUI(); repaintPointer(); } catch(_) {}
        }
      }
    });
    __chartRO.observe(el);
  }
})();
</script>
</body>
</html>