<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Chart Renderer</title>
  <style>
    html,body{height:100%;margin:0}
    /* 关键：隐藏任何超出的绝对定位控件，避免出现滚动条 */
    #chart{width:100%;height:100%; position: relative; overflow: hidden;}

    /* 主题变量（用于轴开关的外观与暗色模式一致） */
    :root{
      --bg-bubble:#ffffff;
      --border-color:#e5e7eb;
      --text-primary:#1f2937;
      --text-:#6b7280;
      --accent:#2563eb;
      --accent-weak:#93c5fd;
      --ok:#16a34a;          /* 绿色激活 */
      --ok-pressed:#15803d;
      --shadow:0 6px 20px rgba(0,0,0,0.12);
      --shadow-strong:0 8px 24px rgba(0,0,0,0.18);
    }
    [data-theme="dark"]{
      --bg-bubble:#1f293700;
      --border-color:#374151;
      --text-primary:#f3f4f6;
      --text-:#9ca3af;
      --accent:#60a5fa;
      --accent-weak:#bfdbfe;
      --ok:#16a34a;
      --ok-pressed:#15803d;
      --shadow:0 6px 20px rgba(0,0,0,0.35);
      --shadow-strong:0 8px 24px rgba(0,0,0,0.45);
    }

    /* 主页同款：X 轴切换控件容器（覆盖标题“转速/噪音”两字） */
    .chart-xaxis-overlay{
      position:absolute;
      z-index:2147483641;
      visibility:hidden;
      transform: translate(-65%, -37%);
    }

    .switch-container { position:relative; width:76px; height:32px; }
    .switch-track { width:100%; height:100%; background:var(--border-color); border-radius:12px; position:relative; overflow:hidden; }
    .switch-track::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      pointer-events: none;
      background: linear-gradient(to bottom, rgba(255,255,255,.22), rgba(255,255,255,0));
      box-shadow:
        inset 0 2px 6px rgba(0,0,0,.10),
        inset 0 -1px 2px rgba(0,0,0,.05);
    }
    [data-theme="dark"] .switch-track::before {
      background: linear-gradient(to bottom, rgba(255,255,255,.08), rgba(255,255,255,0));
      box-shadow:
        inset 0 2px 8px rgba(0,0,0,.45),
        inset 0 -1px 2px rgba(0,0,0,.35);
    }
    .switch-slider {
      position:absolute;
      width:24px;
      height:100%;
      background:var(--text-);
      border-radius:12px;
      left:0; top:0;
      transition:transform .25s ease;
      box-shadow:
        0 2px 5px rgba(0,0,0,.35),
        inset 0 1px 0 rgba(255,255,255,.25),
        inset 0 -1px 0 rgba(0,0,0,.25);
      cursor:grab;
    }
    .switch-label {
      cursor: pointer;
      position:absolute;
      top:46%;
      transform:translateY(-50%);
      font-weight:600;
      font-size:20px;
      color:var(--text-primary);
      white-space:nowrap;
      pointer-events: none;
      user-select: none;
    }
    .switch-label-left { right:calc(100% + 5px); }
    .switch-label-right { left:calc(100% + 5px); }

    .chart-xaxis-overlay,
    .switch-container,
    .switch-track,
    .switch-slider {
      touch-action: none;
    }

    /* 右下角按钮组（按钮式开关） */
    .fit-buttons{
      position: absolute;
      z-index: 2147483645;
      visibility: hidden;
      display: flex;
      gap: 6px;
      pointer-events: auto;
    }
    .fit-buttons .btn{
      appearance: none;
      border: 1px solid var(--border-color);
      background: var(--bg-bubble);
      color: var(--text-primary);
      font-size: 12px;
      font-weight: 700;
      padding: 6px 8px;
      border-radius: 8px;
      cursor: pointer;
      user-select: none;
      line-height: 1;
      box-shadow: var(--shadow);
      transition: transform .02s ease-in-out, background-color .15s ease, color .15s ease;
    }
    .fit-buttons .btn:active{ transform: translateY(1px); }
    .fit-buttons .btn.active{
      background: var(--ok);
      color: #fff;
      border-color: var(--ok);
    }
    .fit-buttons .btn.active:active{ background: var(--ok-pressed); }

    /* 左上角拟合查询“气泡” */
    .fit-bubble{
      position: fixed;
      z-index: 2147483645;
      visibility: hidden;
      min-width: 260px;
      max-width: 420px;
      max-height: 60vh;
      overflow: auto;
      background: var(--bg-bubble);
      backdrop-filter: blur(4px) saturate(120%);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      box-shadow: var(--shadow-strong);
      padding: 10px 12px;
      cursor: grab; 
      touch-action: none;
    }
    .fit-bubble.dragging{          
      cursor: grabbing;
    }
    .fit-bubble .head{
      display:flex; align-items:center; gap:10px;
      margin-bottom: 6px;
    }
    .fit-bubble .title{
      font-weight: 800;
      color: var(--text-primary);
      font-size: 13px;
      line-height: 1.2;
      white-space: nowrap;
    }
    .fit-bubble .x-input{
      margin-left:auto; display:flex; align-items:center; gap:6px;
      font-size:12px; color: var(--text-);
      white-space: nowrap;
    }
    .fit-bubble input[type="number"]{
      width: 10ch;
      font-size: 12px;
      padding: 4px 6px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: transparent;
      color: var(--text-primary);
      outline: none;
    }
    .fit-bubble .row{
      display:flex; align-items:center; gap:8px; margin: 4px 0;
      color: var(--text-primary);
      font-size: 13px;
    }
    .fit-bubble .row .dot{
      width:10px; height:10px; border-radius:50%;
      flex:0 0 auto;
    }
    .fit-bubble .hint{
      color: var(--text-);
      font-size: 11px;
      margin-top: 6px;
    }

    /* 可拖指针（带矩形把手 + 向下箭头） */
    .fit-pointer{
      position: absolute;
      z-index: 2147483644;
      visibility: hidden;
      pointer-events: none;
    }
    .fit-pointer .line{
      position:absolute;
      top:0; bottom:0;
      width: 2px;
      transform: translateX(-1px);
      background: var(--accent);
      opacity: 0.95;
    }
    .fit-pointer .handle{
      position:absolute;
      bottom:-22px; left:-8px;
      width:16px; height:24px;
      border-radius:4px;
      background: var(--accent);
      box-shadow: var(--shadow);
      cursor: grab;
      touch-action: none;
      pointer-events: auto;
    }
    .fit-pointer .handle::after{
      content:"";
      position:absolute;
      left:50%; transform: translateX(-50%);
      top:-7px;
      width: 0; height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 9px solid var(--accent);
    }

    .fit-narrow-hint{
      position:absolute;
      z-index:2147483643;
      font-size:11px;
      color: var(--text-);
      pointer-events:none;
      user-select:none;
      white-space:nowrap;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.2/dist/echarts.min.js"></script>
</head>
<body>
  <div id="chart"></div>
<script>
(function () {
  let chart;
  let lastOption = null;
  let lastPayload = null;
  let isFs = false;
  let lastIsNarrow = null;

  // NEW: 气泡拖拽状态（仅本次会话，不持久化）
  let bubbleUserMoved = false;
  const bubblePos = { left: null, top: null };

  // X 轴模式覆盖：'rpm' | 'noise_db' | null
  let xAxisOverride = null;

  // 动画保护窗口
  let axisSnapSuppressUntil = 0;

  window.__FS_TOGGLE_OFFSET = window.__FS_TOGGLE_OFFSET || { x: 0, y: 0 };

  const TITLE_GLUE = '  -  ';

  function isMobile(){
    return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent)
      || (window.matchMedia && window.matchMedia('(pointer:coarse)').matches);
  }

  function layoutIsNarrow() {
    const w = chart && typeof chart.getWidth === 'function'
      ? chart.getWidth()
      : (typeof window !== 'undefined' ? window.innerWidth : 0);
    let narrow = w < 600;
    if (isFs && isMobile()) narrow = false;
    return narrow;
  }

  // ====== 拟合功能状态 ======
  const FIT_ALGO_NAME = '趋势拟合';
  let showRawCurves = true;    // “ECHARTS曲线”
  let showFitCurves = false;   // “PCHIP 拟合”
  const FIT_TENSION = 0.85;    // 仅代码参数

  const xQueryByMode = { rpm: null, noise_db: null };
  const fitModelsCache = { rpm: new Map(), noise_db: new Map() };
  const fitSamplesCache = { rpm: new Map(), noise_db: new Map(), sampleCount: 0, domain: { rpm:[null,null], noise_db:[null,null] } };
  let fitUIInstalled = false;

  function init() {
    chart = echarts.init(document.getElementById('chart'), null, {
      renderer:'canvas',
      devicePixelRatio: window.devicePixelRatio || 1
    });

    window.addEventListener('resize', () => {
      if (!chart) return;
      const nowNarrow = layoutIsNarrow();
      if (lastIsNarrow === null) lastIsNarrow = nowNarrow;

      if (nowNarrow !== lastIsNarrow) {
        lastIsNarrow = nowNarrow;
        if (lastPayload) render(lastPayload);
        else chart.resize();
      } else {
        chart.resize();
        if (lastOption) {
          const { x, y, visible } = computePrefixCenter(lastOption);
          placeAxisOverlayAt(x, y, visible && !lastOption.__empty);
          placeFitUI();
          repaintPointer();
        }
      }
    });

    document.addEventListener('fullscreenchange', async () => {
      isFs = !!document.fullscreenElement;
      if (!isFs) {
        if (screen.orientation && screen.orientation.unlock) {
          try { screen.orientation.unlock(); } catch(_) {}
        }
      }
      const nowNarrow = layoutIsNarrow();
      if (lastIsNarrow === null) lastIsNarrow = nowNarrow;

      if (nowNarrow !== lastIsNarrow) {
        lastIsNarrow = nowNarrow;
        if (lastPayload) render(lastPayload);
        else chart && chart.resize();
      } else {
        chart && chart.resize();
        if (lastOption) {
          const { x, y, visible } = computePrefixCenter(lastOption);
          placeAxisOverlayAt(x, y, visible && !lastOption.__empty);
          placeFitUI();
          repaintPointer();
        }
      }
    });

    chart.on('legendselectchanged', () => {
      if (showFitCurves) refreshFitBubble();
    });

    chart.on('dataZoom', () => {
      clampXQueryIntoVisibleRange();
      repaintPointer();
      if (showFitCurves) refreshFitBubble();
    });
  }

  // X 轴模式开关（原有逻辑保留）
  function updateAxisSwitchPosition(opts = {}) {
    const { force = false, animate = false } = opts;
    if (!force && performance.now() < axisSnapSuppressUntil) return;
    const track  = document.getElementById('xAxisSwitchTrack');
    const slider = document.getElementById('xAxisSwitchSlider');
    if (!track || !slider) return;

    const sliderWidth = slider.offsetWidth || 0;
    const trackWidth  = track.offsetWidth || 0;
    const maxX = Math.max(0, trackWidth - sliderWidth);

    const currType = currentXModeFromPayload(lastPayload);
    const toNoise  = (currType === 'noise_db');

    slider.style.transition = animate ? 'transform .25s ease' : 'none';
    slider.style.transform  = `translateX(${toNoise ? maxX : 0}px)`;
    track.setAttribute('aria-checked', String(toNoise));
  }

  function ensureAxisOverlay(){
    let overlay = document.getElementById('chartXAxisOverlay');
    if (!overlay){
      overlay = document.createElement('div');
      overlay.id = 'chartXAxisOverlay';
      overlay.className = 'chart-xaxis-overlay';
      overlay.setAttribute('aria-label','X轴切换');
      overlay.innerHTML = `
        <div class="switch-container" id="xAxisSwitchContainer">
          <div class="switch-track" id="xAxisSwitchTrack">
            <div class="switch-slider" id="xAxisSwitchSlider">
              <span class="switch-label switch-label-right">转速</span>
              <span class="switch-label switch-label-left">噪音</span>
            </div>
          </div>
        </div>`;
      document.getElementById('chart').appendChild(overlay);
      bindXAxisSwitch();
      requestAnimationFrame(() => updateAxisSwitchPosition({ force: true, animate: false }));
    }
    return overlay;
  }

  function bindXAxisSwitch(){
    const xAxisSwitchTrack = document.getElementById('xAxisSwitchTrack');
    const xAxisSwitchSlider = document.getElementById('xAxisSwitchSlider');
    if (!xAxisSwitchTrack || !xAxisSwitchSlider) return;

    let sliderWidth = 0, trackWidth = 0, maxX = 0;
    let dragging = false, dragMoved = false, startX = 0, base = 0, activePointerId = null;

    try {
      xAxisSwitchTrack.setAttribute('role', 'switch');
      xAxisSwitchTrack.setAttribute('aria-checked', String((currentXModeFromPayload(lastPayload) || 'rpm') !== 'rpm'));
    } catch(_) {}

    function measure() {
      sliderWidth = xAxisSwitchSlider.offsetWidth || 0;
      trackWidth  = xAxisSwitchTrack.offsetWidth || 0;
      maxX = Math.max(0, trackWidth - sliderWidth);
    }

    function pos(type, animate = true) {
      const toNoise = (type === 'noise_db' || type === 'noise');
      const x = toNoise ? maxX : 0;
      xAxisSwitchSlider.style.transition = animate ? 'transform .25s ease' : 'none';
      xAxisSwitchSlider.style.transform  = `translateX(${x}px)`;
      xAxisSwitchTrack.setAttribute('aria-checked', String(toNoise));
    }

    function protectSliderAnimationWindow() {
      axisSnapSuppressUntil = performance.now() + 360;
    }

    xAxisSwitchSlider.addEventListener('transitionend', () => {
      axisSnapSuppressUntil = 0;
    });

    function applyType(newType) {
      const normalized = (newType === 'noise') ? 'noise_db' : newType;
      if (normalized !== 'rpm' && normalized !== 'noise_db') return;
      if (xAxisOverride === normalized) return;
      xAxisOverride = normalized;
      try { localStorage.setItem('x_axis_type', normalized); } catch(_) {}
      pos(normalized, true);
      protectSliderAnimationWindow();
      if (lastPayload) render(lastPayload);
      try {
        window.parent.postMessage({
          type:'chart:xaxis-type-changed',
          payload:{ x_axis_type: normalized, fullscreen: !!document.fullscreenElement, source:'iframe' }
        }, window.location.origin);
      } catch(_){}
    }

    function nearestType() {
      const m = new DOMMatrix(getComputedStyle(xAxisSwitchSlider).transform);
      const cur = m.m41 || 0;
      return cur > maxX / 2 ? 'noise_db' : 'rpm';
    }

    function onPointerDown(e) {
      if (e.button !== undefined && e.button !== 0) return;
      measure();
      dragging = true;
      dragMoved = false;
      activePointerId = e.pointerId ?? null;
      startX = e.clientX;
      const m = new DOMMatrix(getComputedStyle(xAxisSwitchSlider).transform);
      base = m.m41 || 0;
      xAxisSwitchSlider.style.transition = 'none';
      try { if (activePointerId != null) xAxisSwitchSlider.setPointerCapture(activePointerId); } catch(_){}
      e.preventDefault?.();
    }

    function onPointerMove(e) {
      if (!dragging) return;
      const dx = e.clientX - startX;
      if (!dragMoved && Math.abs(dx) > 2) dragMoved = true;
      let x = base + dx;
      x = Math.max(0, Math.min(x, maxX));
      xAxisSwitchSlider.style.transform = `translateX(${x}px)`;
    }

    function finishDrag() {
      if (!dragging) return;
      dragging = false;
      try { if (activePointerId != null) xAxisSwitchSlider.releasePointerCapture(activePointerId); } catch(_){}
      activePointerId = null;
      const newType = nearestType();
      pos(newType, true);
      applyType(newType);
    }

    function cancelDrag() {
      if (!dragging) return;
      dragging = false;
      try { if (activePointerId != null) xAxisSwitchSlider.releasePointerCapture(activePointerId); } catch(_){}
      activePointerId = null;
      pos(currentXModeFromPayload(lastPayload), true);
    }

    xAxisSwitchTrack.addEventListener('click', () => {
      if (dragMoved) { dragMoved = false; return; }
      const curr = currentXModeFromPayload(lastPayload);
      const next = (curr === 'rpm') ? 'noise_db' : 'rpm';
      pos(next, true);
      applyType(next);
    });

    xAxisSwitchTrack.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove, { passive: true });
    window.addEventListener('pointerup', finishDrag, { passive: true });
    window.addEventListener('pointercancel', cancelDrag);
    window.addEventListener('blur', cancelDrag);

    measure();
    pos(currentXModeFromPayload(lastPayload), false);
    window.addEventListener('resize', () => {
      const keep = currentXModeFromPayload(lastPayload);
      measure();
      pos(keep, false);
    });
  }

  function placeAxisOverlayAt(x, y, show){
    const overlay = ensureAxisOverlay();
    const off = window.__FS_TOGGLE_OFFSET || { x: 0, y: 0 };
    overlay.style.left = (x + (Number(off.x)||0)) + 'px';
    overlay.style.top  = (y + (Number(off.y)||0)) + 'px';
    overlay.style.visibility = show ? 'visible' : 'hidden';
    requestAnimationFrame(() => updateAxisSwitchPosition());
  }

  function render(payload){
    if (!chart) init();

  // 记录前后 x 模式与空状态，用于决定是否需要彻底清空以避免残留
  const prevXMode = currentXModeFromPayload(lastPayload);
  const prevEmpty = !!(lastOption && lastOption.__empty);

  lastPayload = payload || lastPayload;
  syncThemeAttr((lastPayload && lastPayload.theme) || 'light');

  if (!fitUIInstalled) {
    ensureFitUI();
    fitUIInstalled = true;
  }

  const option = buildOption(lastPayload);
  const nextXMode = currentXModeFromPayload(lastPayload);
  const nextEmpty = !!option.__empty;

  // 关键：当“轴模式变化”或“空/非空状态变化”时，先 clear 再 setOption，避免 ECharts 内部残留（例如 0 处指示线）
  if (prevXMode !== nextXMode || prevEmpty !== nextEmpty) {
    try { chart.clear(); } catch(_) {}
  }

  chart.setOption(option, true);
  chart.resize();

  requestAnimationFrame(() => updateAxisSwitchPosition());
  // 空图时，主动撤销轴指示线的残留（双保险）
  if (option.__empty) {
    try { chart.dispatchAction({ type: 'updateAxisPointer', currTrigger: 'leave' }); } catch(_) {}
  }

  const { x, y, visible } = computePrefixCenter(option);
  placeAxisOverlayAt(x, y, visible && !option.__empty);

  lastOption = option;
  lastIsNarrow = layoutIsNarrow();

  toggleFitUI(showFitCurves && !layoutIsNarrow());
  placeFitUI();
  repaintPointer();
  if (showFitCurves) refreshFitBubble();

}

  async function enterFullscreen(){
    const el = document.documentElement;
    try {
      await el.requestFullscreen();
      isFs = true;
      if (isMobile() && screen.orientation && screen.orientation.lock) {
        try { await screen.orientation.lock('landscape'); } catch(_) {}
      }
    } catch(err){
      console.warn('requestFullscreen 失败：', err);
    } finally {
      if (lastPayload) render(lastPayload); else chart && chart.resize();
    }
  }
  async function exitFullscreen(){
    try { if (document.fullscreenElement) await document.exitFullscreen(); }
    catch(err){ console.warn('exitFullscreen 失败：', err); }
    finally {
      isFs = false;
      if (lastPayload) render(lastPayload); else chart && chart.resize();
    }
  }
  function toggleFullscreen(){
    if (document.fullscreenElement) exitFullscreen(); else enterFullscreen();
  }

  function getExportBg() {
    const bg = getComputedStyle(document.body).backgroundColor;
    return bg && bg !== 'rgba(0, 0, 0, 0)' ? bg : '#ffffff';
  }

  function tokens(theme) {
    const dark = (theme||'').toLowerCase()==='dark';
    return {
      fontFamily:'system-ui,-apple-system,"Segoe UI","Helvetica Neue","Microsoft YaHei",Arial,sans-serif',
      axisLabel: dark ? '#d1d5db' : '#4b5563',
      axisName:  dark ? '#9ca3af' : '#6b7280',
      axisLine:  dark ? '#374151' : '#e5e7eb',
      gridLine:  dark ? 'rgba(255,255,255,0.10)' : 'rgba(0,0,0,0.08)',
      tooltipBg: dark ? 'rgba(17,24,39,0.97)' : 'rgba(255,255,255,0.98)',
      tooltipBorder: dark ? '#374151' : '#e5e7eb',
      tooltipText: dark ? '#f3f4f6' : '#1f2937',
      tooltipShadow: dark ? '0 6px 20px rgba(0,0,0,0.35)' : '0 6px 20px rgba(0,0,0,0.12)',
      pagerIcon: dark ? '#93c5fd' : '#2563eb'
    };
  }

  function currentXModeFromPayload(payload){
    const inPay = (payload?.chartData?.x_axis_type === 'noise_db' || payload?.chartData?.x_axis_type === 'noise') ? 'noise_db' : 'rpm';
    if (xAxisOverride) return xAxisOverride;
    return inPay;
  }

  function buildSeries(rawSeries, xMode) {
    let maxAir = 0;
    let minX = +Infinity, maxX = -Infinity;
    const series = rawSeries.map(s => {
      const xArr = (s[xMode] || []).map(Number);
      const yArr = (s.airflow || []).map(Number);
      const tipArr = (xMode === 'rpm' ? s.noise_db : s.rpm) || [];
      const len = Math.min(xArr.length, yArr.length, tipArr.length || xArr.length);
      const data = [];
      for (let i = 0; i < len; i++) {
        const x = xArr[i], y = yArr[i], tip = Number(tipArr[i]);
        if (Number.isFinite(x)) { minX = Math.min(minX, x); maxX = Math.max(maxX, x); }
        if (Number.isFinite(y)) { maxAir = Math.max(maxAir, y); }
        data.push({ value: [x, y], tip });
      }
      return {
        name: s.name,
        type: 'line',
        smooth: true,
        connectNulls: false,
        showSymbol: true,
        symbol: 'circle',
        symbolSize: 8,
        lineStyle: { width: 3, color: s.color },
        itemStyle: { color: s.color },
        label: { show: true, position: 'top', color: 'gray' },
        legendHoverLink: true,
        emphasis: {
          focus: 'series',
          blurScope: 'coordinateSystem',
          lineStyle: { width: 4 },
          itemStyle: { borderWidth: 1.2, shadowColor: 'rgba(0,0,0,0.25)', shadowBlur: 8 },
          label: { show: true }
        },
        blur: {
          lineStyle: { opacity: 0.18 },
          itemStyle: { opacity: 0.18 },
          label: { show: false }
        },
        data
      };
    });

    if (minX === +Infinity) { minX = 0; maxX = 100; }
    if (maxAir <= 0) maxAir = 100;

    const span = Math.max(1, maxX - minX);
    const pad = Math.floor(span * 0.2);
    return { series, xMin: Math.max(minX - pad, 0), xMax: maxX + pad, yMax: Math.ceil(maxAir * 1.4) };
  }

  function buildOption(payload) {
    const { chartData, theme } = payload || {};
    const t = tokens(theme||'light');
    const sList = Array.isArray(chartData?.series) ? chartData.series : [];
    const xMode = currentXModeFromPayload(payload);

    let isNarrow = chart && typeof chart.getWidth === 'function'
      ? (chart.getWidth() < 600)
      : (typeof window !== 'undefined' ? window.innerWidth < 600 : false);

    if (isFs && isMobile()) isNarrow = false;
    if (isNarrow) {
        // 窄屏：固定只显示 ECHARTS 曲线
        if (!showRawCurves) showRawCurves = true;
        if (showFitCurves) showFitCurves = false;
        }

    const exportBg = (payload && payload.chartBg) || getExportBg();
    const bgNormal = isFs ? exportBg : 'transparent';

    if (!sList.length || (!showRawCurves && !showFitCurves)) {
      toggleFitUI(false);
      return {
        __empty:true,
        backgroundColor: bgNormal,
        title:{ text:'暂无数据', left:'center', top:'middle',
          textStyle:{ color:t.axisLabel, fontFamily:t.fontFamily } },
        toolbox:{
           feature:{ 
            saveAsImage:{ 
              backgroundColor:exportBg, 
              pixelRatio: window.devicePixelRatio || 1 
            } 
          } 
        },
        tooltip:{ show:false, triggerOn:'none' }
      };
    }

    const built = buildSeries(sList, xMode);
    const xName = xMode==='rpm' ? '转速(RPM)' : '噪音(dB)';
    const titlePrefix = xMode==='rpm' ? '转速' : '噪音';
    const bgColor = (payload && payload.chartBg) || getExportBg();

    const titleTop = 10;
    const titleFontSize = 20;
    const titleFontWeight = 600;
    const titleText = `${titlePrefix}${TITLE_GLUE}风量曲线`;
    const titleMeasure = measureText(titleText, titleFontSize, titleFontWeight, t.fontFamily);
    const gridTop = Math.max(54, titleTop + Math.ceil(titleMeasure.height) + 12);

    const legendReserveRightPx = isNarrow ? 20 : 260;
    const legendReserveBottomPx = isNarrow ? Math.min(320, 50 + (sList.length || 1) * 22) : 40;

    const legendMeta = {};
    sList.forEach(s=>{
      const brand = s.brand || s.brand_name_zh || s.brand_name || '';
      const model = s.model || s.model_name || '';
      const rt    = s.res_type || s.resistance_type_zh || s.resistance_type || s.rt || '';
      const rl    = s.res_loc || s.resistance_location_zh || s.resistance_location || s.rl || '';
      const key   = s.name || [brand, model].filter(Boolean).join(' ') || String(s.key || '');
      legendMeta[key] = { brand, model, rt, rl };
    });
    function desktopLegendFormatter(name){
      const m = legendMeta[name] || {};
      const line1 = [m.brand, m.model].filter(Boolean).join(' ');
      const line2 = [m.rt, m.rl].filter(Boolean).join(' ');
      if (line2) return `{l1|${line1}}\n{l2|${line2}}`;
      return `{l1|${line1||name}}`;
    }
    function mobileLegendFormatter(name){
      const m = legendMeta[name] || {};
      const left = [m.brand, m.model].filter(Boolean).join(' ');
      const right = [m.rt, m.rl].filter(Boolean).join(' ');
      if (right) return `{m1|${left}} {m1|-} {m2|${right}}`;
      return `{m1|${left||name}}`;
    }
    const isN = isNarrow;
    const legendCfg = isN ? {
      type: 'scroll',
      orient: 'vertical',
      left: 20, right: 6, bottom: 6,
      itemWidth: 16, itemHeight: 10, align: 'auto',
      pageIconColor: t.pagerIcon, pageTextStyle: { color: t.axisLabel },
      textStyle: { color: t.axisLabel, fontFamily: t.fontFamily,
        rich: { m1:{ fontSize:13,fontWeight:600,color:t.axisLabel,lineHeight:18 },
                m2:{ fontSize:11,fontWeight:500,color:t.axisName,lineHeight:16 } } },
      formatter: mobileLegendFormatter
    } : {
      type: 'scroll',
      orient: 'vertical',
      right: 80, top: gridTop, bottom: 10,
      itemWidth: 18, itemHeight: 10, itemGap: 16, align: 'auto',
      pageIconColor: t.pagerIcon, pageTextStyle: { color: t.axisLabel },
      textStyle: { color: t.axisLabel, fontFamily: t.fontFamily,
        rich: { l1:{ fontSize:13,fontWeight:600,color:t.axisLabel,lineHeight:18 },
                l2:{ fontSize:11,fontWeight:500,color:t.axisName,lineHeight:14 } } },
      formatter: desktopLegendFormatter
    };
    try {
      const prevSel = chart && chart.getOption && chart.getOption().legend && chart.getOption().legend[0] && chart.getOption().legend[0].selected;
      if (prevSel) legendCfg.selected = prevSel;
    } catch(_){}

    const iconEnter = 'path://M3 10v-7h7M3 3l7 7M21 14v7h-7M21 21l-7-7';
    const iconExit  = 'path://M3 7v7h7M3 14l7-7M21 17v-7h-7M21 10l-7 7';

    const finalSeries = [];
    if (showRawCurves) {
      built.series.forEach(s => finalSeries.push(s));
    }

    if (showFitCurves) {
    ensureFitModels(sList, xMode);
      
    const width = Math.max(300, chart.getWidth ? chart.getWidth() : 800);
    const sampleCount = computeSampleCount(width);
    if (fitSamplesCache.sampleCount !== sampleCount) fitSamplesCache.sampleCount = sampleCount;
      
    sList.forEach(s => {
      const model = fitModelsCache[xMode].get(s.name);
      if (!model || model.x0 == null || model.x1 == null) return;
      const sMin = Math.min(model.x0, model.x1);
      const sMax = Math.max(model.x0, model.x1);
      const xmin = Math.max(built.xMin, sMin);
      const xmax = Math.min(built.xMax, sMax);
      if (!(xmax > xmin)) return;
    
      const pts = resampleSingle(model, xmin, xmax, sampleCount, FIT_TENSION);
      fitSamplesCache[xMode].set(s.name, pts);
    
      finalSeries.push({
        id: `fit-line:${xMode}:${s.name}`,
        name: s.name,
        type: 'line',
        smooth: false,
        showSymbol: false,
        connectNulls: false,
        data: pts.map(p => [p.x, p.y]),
        lineStyle: { width: 2.5, type:'dashed', color: s.color, opacity: 0.95 },
        itemStyle: { color: s.color },
        // 去掉切换动画（echarts 对虚线过渡有限），保留 legend 悬停高亮
        legendHoverLink: true,
        emphasis: {
          focus: 'series',
          blurScope: 'coordinateSystem',
          lineStyle: { width: 3.5, opacity: 1 },
          itemStyle: { opacity: 1 }
        },
        blur: {
          lineStyle: { opacity: 0.2 },
          itemStyle: { opacity: 0.2 }
        },
        silent: false,
        tooltip: { show: false },
        z: 3
      });
    });
  }


    return {
      __empty:false,
      __titlePrefix:titlePrefix,
      __themeTokens:t,
      __titleTop: titleTop,
      __titleFontSize: titleFontSize,
      __titleFontWeight: titleFontWeight,
      __titleFamily: t.fontFamily,

      backgroundColor: bgNormal,
      color: sList.map(s=>s.color),
      textStyle:{ fontFamily:t.fontFamily },
      stateAnimation: { duration: 220, easing: 'cubicOut' },

      grid:{ left:40, right: (isN ? 20 : 260), top: gridTop, bottom: (isN ? Math.min(320, 50 + (sList.length || 1) * 22) : 40) },

      title: {
        text: titleText,
        left: 'center',
        top: titleTop,
        textStyle: { color: t.axisLabel, fontSize: titleFontSize, fontWeight: titleFontWeight, fontFamily: t.fontFamily }
      },

      legend: legendCfg,

      xAxis:{
        type:'value', name:xName, nameLocation:'middle', nameGap:25, nameMoveOverlap:true,
        nameTextStyle:{ color:t.axisName, fontWeight:600, fontFamily:t.fontFamily, textShadowColor:'rgba(0,0,0,0.28)', textShadowBlur:4, textShadowOffsetY:1 },
        axisLabel:{ color:t.axisLabel, fontSize:12, fontFamily:t.fontFamily, margin:10 },
        axisLine:{ lineStyle:{ color:t.axisLine }},
        splitLine:{ show:true, lineStyle:{ color:t.gridLine }},
        min: 0, max: built.xMax * 1.2
      },
      yAxis:{
        type:'value', name:'风量(CFM)', min:0, max: built.yMax * 1.3,
        nameTextStyle:{ color:t.axisName, fontWeight:600, textShadowColor:'rgba(0,0,0,0.28)', textShadowBlur:4, textShadowOffsetY:1 },
        axisLabel:{ color:t.axisLabel }, axisLine:{ lineStyle:{ color:t.axisLine }},
        splitLine:{ show:true, lineStyle:{ color:t.gridLine }}
      },

      tooltip:{
        axisPointer: {
          type: "cross", 
          label: {
          color: t.tooltipText
          }
        },
        trigger:'item',
        backgroundColor:t.tooltipBg,
        borderColor:t.tooltipBorder,
        textStyle:{ color:t.tooltipText },
        extraCssText:`box-shadow:${t.tooltipShadow};`,
        formatter:function(p){
          const xModeNow = currentXModeFromPayload(lastPayload);
          const xLabel = xModeNow==='rpm' ? 'RPM, ' : 'dB, ';
          const infoLabel = xModeNow==='rpm' ? 'dB' : 'RPM';
          const x = p.value?.[0], y = p.value?.[1];
          const tip = p.data?.tip ?? '';
          const dot = `<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${p.color};margin-right:4px;"></span>`;
          return `${dot}${p.seriesName}<br/>&nbsp;&nbsp;&nbsp;&nbsp;${y}CFM @${x}${xLabel}${tip}${infoLabel}`;
        }
      },

      toolbox:{
        top: -5, right: 0,
        feature:{
          dataZoom:{ yAxisIndex:'none' },
          restore:{},
          saveAsImage:{ 
            backgroundColor:exportBg, 
            pixelRatio: window.devicePixelRatio || 1 
          },
          myFullscreen: {
            show: true,
            title: !!document.fullscreenElement ? '退出全屏' : '全屏查看',
            icon: !!document.fullscreenElement ? iconExit : iconEnter,
            onclick: () => toggleFullscreen()
          }
        }
      },

      dataZoom: [
        { type: 'inside', xAxisIndex: 0, throttle: 50, zoomOnMouseWheel: true, moveOnMouseWheel: true, moveOnMouseMove: true ,filterMode: "none", startValue: built.xMin, endValue: built.xMax },
        { type: 'inside', yAxisIndex: 0, throttle: 50, zoomOnMouseWheel: 'alt', moveOnMouseWheel: 'alt', moveOnMouseMove: true ,filterMode: "none", endValue: built.yMax}
      ],

      series: finalSeries
    };
  }

  function measureText(text, size, weight, family){
    const c = document.createElement('canvas');
    const ctx = c.getContext('2d');
    ctx.font = `${String(weight||400)} ${Number(size||14)}px ${family||'sans-serif'}`;
    const m = ctx.measureText(text || '');
    const width = m.width || 0;
    const ascent = (typeof m.actualBoundingBoxAscent === 'number') ? m.actualBoundingBoxAscent : size * 0.8;
    const descent = (typeof m.actualBoundingBoxDescent === 'number') ? m.actualBoundingBoxDescent : size * 0.2;
    return { width, height: ascent + descent };
  }

  function computePrefixCenter(option){
    if (!chart || !option || !option.title) return { x: 0, y: 0, visible:false };
    if (option.__empty) return { x: 0, y: 0, visible:false };
    const title = option.title;
    const ts = title.textStyle || {};
    const size = Number(ts.fontSize || option.__titleFontSize || 14);
    const weight = ts.fontWeight || option.__titleFontWeight || 600;
    const family = ts.fontFamily || option.__titleFamily;
    const prefix = String(option.__titlePrefix || '');
    const totalText = `${prefix}${TITLE_GLUE}风量曲线`;

    const mTotal = measureText(totalText, size, weight, family);
    const mPrefix = measureText(prefix, size, weight, family);
    const chartW = chart.getWidth();
    const centerX = chartW / 2;
    const totalLeft = centerX - mTotal.width / 2;
    const prefixCenterX = totalLeft + mPrefix.width / 2;
    const top = (typeof title.top === 'number') ? title.top : 0;
    const centerY = top + (mTotal.height / 2);
    return { x: Math.round(prefixCenterX), y: Math.round(centerY), visible:true };
  }

  function syncThemeAttr(theme){
    const t = String(theme || 'light').toLowerCase();
    document.documentElement.setAttribute('data-theme', t);
    document.body.setAttribute('data-theme', t);
  }

  // 工具：轴的一维像素/数据互转
  function pxToDataX(xPixel){
    try {
      return chart.convertFromPixel({ xAxisIndex: 0 }, xPixel);
    } catch(e){ return NaN; }
  }
  function dataToPxX(xData){
    try {
      return chart.convertToPixel({ xAxisIndex: 0 }, xData);
    } catch(e){ return NaN; }
  }

  function ensureNarrowHint(){
      const root = document.getElementById('chart');
      let hint = document.getElementById('narrowHint');
      if (!hint){
        hint = document.createElement('div');
        hint.id = 'narrowHint';
        hint.className = 'fit-narrow-hint';
        hint.textContent = `${FIT_ALGO_NAME}曲线请在图表右上角切换至全屏模式`;
        root.appendChild(hint);
      }
      return hint;
    }

  // ====== 拟合 UI（按钮组 + 气泡 + 指针） ======
  function ensureFitUI(){
    const root = document.getElementById('chart');

    // 右下角按钮组
    let btns = document.getElementById('fitButtons');
    if (!btns){
      btns = document.createElement('div');
      btns.id = 'fitButtons';
      btns.className = 'fit-buttons';
      btns.innerHTML = `
        <button class="btn" id="btnRaw">ECHARTS<br>曲线</button>
        <button class="btn" id="btnFit">${FIT_ALGO_NAME}<br>曲线</button>
      `;
      root.appendChild(btns);
      const btnRaw = btns.querySelector('#btnRaw');
      const btnFit = btns.querySelector('#btnFit');
      function syncButtons(){
        btnRaw.classList.toggle('active', showRawCurves);
        btnFit.classList.toggle('active', showFitCurves);
      }
      function ensureAtLeastOne(onWhich){
        if (!showRawCurves && !showFitCurves){
          if (onWhich === 'raw') showFitCurves = true; else showRawCurves = true;
        }
      }
      btnRaw.addEventListener('click', ()=>{
        showRawCurves = !showRawCurves;
        ensureAtLeastOne('raw');
        syncButtons();
        if (lastPayload) render(lastPayload);
      });
      btnFit.addEventListener('click', ()=>{
        showFitCurves = !showFitCurves;
        ensureAtLeastOne('fit');
        syncButtons();
        if (lastPayload) render(lastPayload);
      });
      syncButtons();
    }

    // 左上角气泡
    let bubble = document.getElementById('fitBubble');
    if (!bubble){
      bubble = document.createElement('div');
      bubble.id = 'fitBubble';
      bubble.className = 'fit-bubble';
      bubble.innerHTML = `
        <div class="head">
          <div class="title">${FIT_ALGO_NAME} 估算值</div>
          <div class="x-input">
            <span>当前位置</span>
            <input id="fitXInput" type="number" step="1" />
            <span id="fitXUnit"></span>
          </div>
        </div>
        <div id="fitBubbleRows"></div>
        <div class="hint">按系列可见性（Legend）过滤，按风量从大到小排序</div>
      `;
      root.appendChild(bubble);

      // NEW: 绑定气泡拖拽
      bindBubbleDrag(bubble);

      const xInput = bubble.querySelector('#fitXInput');
      xInput.addEventListener('input', onBubbleInputLive);
      xInput.addEventListener('change', onBubbleInputCommit);
      xInput.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter') { onBubbleInputCommit(); }
      });
    }

    // 指针
    let ptr = document.getElementById('fitPointer');
    if (!ptr){
      ptr = document.createElement('div');
      ptr.id = 'fitPointer';
      ptr.className = 'fit-pointer';
      ptr.innerHTML = `
        <div class="line"></div>
        <div class="handle" id="fitPointerHandle"></div>
      `;
      root.appendChild(ptr);
      bindPointerDrag();
    }
  }

    // NEW: 气泡拖拽逻辑（鼠标 + 触摸均可；输入框等交互元素不触发拖拽）
  function bindBubbleDrag(bubble){
    if (!bubble) return;

    let activePointerId = null;
    let startX = 0, startY = 0;
    let baseLeft = 0, baseTop = 0;
    let dragging = false;
    const DRAG_THRESHOLD = 4; // 像素阈值：避免误触滚动/点击

    function isInteractiveTarget(el){
      return !!(el && (el.closest('input, textarea, select, button, [contenteditable=""], [contenteditable="true"]')));
    }

    function onPointerDown(e){
      if (e.button !== undefined && e.button !== 0) return;      // 仅左键/单指
      if (isInteractiveTarget(e.target)) return;                 // 输入框等不触发拖拽

      const rect = bubble.getBoundingClientRect();
      startX   = e.clientX;
      startY   = e.clientY;
      baseLeft = rect.left;
      baseTop  = rect.top;
      dragging = false;

      activePointerId = e.pointerId ?? null;
      try { if (activePointerId != null) bubble.setPointerCapture(activePointerId); } catch(_){}
      // 不阻止默认，允许点击/选择文本；真正开始拖拽后再 preventDefault
    }

    function onPointerMove(e){
      if (activePointerId != null && (e.pointerId ?? null) !== activePointerId) return;
      if (activePointerId == null) return;

      const dx = e.clientX - startX;
      const dy = e.clientY - startY;

      if (!dragging && Math.hypot(dx, dy) > DRAG_THRESHOLD){
        dragging = true;
        bubble.classList.add('dragging');
      }
      if (!dragging) return;

      if (e.cancelable) e.preventDefault();

      const bw = bubble.offsetWidth  || 0;
      const bh = bubble.offsetHeight || 0;
      const vw = window.innerWidth   || document.documentElement.clientWidth  || 0;
      const vh = window.innerHeight  || document.documentElement.clientHeight || 0;

      let newLeft = baseLeft + dx;
      let newTop  = baseTop  + dy;

      newLeft = Math.min(Math.max(0, newLeft), Math.max(0, vw - bw));
      newTop  = Math.min(Math.max(0, newTop ), Math.max(0, vh - bh));

      bubble.style.left = Math.round(newLeft) + 'px';
      bubble.style.top  = Math.round(newTop)  + 'px';
      bubble.style.right  = 'auto';
      bubble.style.bottom = 'auto';

      bubblePos.left = newLeft;
      bubblePos.top  = newTop;
      bubbleUserMoved = true;
    }

    function endDrag(){
      if (activePointerId == null) return;
      try { bubble.releasePointerCapture(activePointerId); } catch(_){}
      activePointerId = null;
      dragging = false;
      bubble.classList.remove('dragging');
    }

    bubble.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove, { passive:false });
    window.addEventListener('pointerup',   endDrag,       { passive:true  });
    window.addEventListener('pointercancel', endDrag,     { passive:true  });
    window.addEventListener('blur', endDrag);
  }


  function toggleFitUI(showFit){
  const btns = document.getElementById('fitButtons');
  const bubble = document.getElementById('fitBubble');
  const ptr = document.getElementById('fitPointer');
  const narrow = layoutIsNarrow();
  const empty  = !lastOption || lastOption.__empty;

  // 窄屏一律隐藏按钮；仅在非空且非窄屏时显示
  if (btns) btns.style.visibility = (empty || narrow) ? 'hidden' : 'visible';

  // 气泡与指针：仅在非窄屏且拟合开启时显示
  const showFloating = showFit && !narrow && !empty;
  if (bubble) bubble.style.visibility = showFloating ? 'visible' : 'hidden';
  if (ptr)    ptr.style.visibility    = showFloating ? 'visible' : 'hidden';
}

  function placeFitUI(){
    const btns = document.getElementById('fitButtons');
    const bubble = document.getElementById('fitBubble');
    if (!lastOption) return;

    const grid = lastOption.grid || { left:40, right: 260, top: 60, bottom: 40 };
    const chartW = chart ? chart.getWidth() : 800;
    const chartH = chart ? chart.getHeight() : 600;
    const left = (typeof grid.left==='number') ? grid.left : 40;
    const rightGap = (typeof grid.right==='number') ? grid.right : 260;
    const top = (typeof grid.top==='number') ? grid.top : 60;
    const bottomGap = (typeof grid.bottom==='number') ? grid.bottom : 40;

    const pad = 6;

    // 右下角按钮组：定位到坐标轴外的目标点，并对容器边缘做夹持，避免溢出
    if (btns){
      const bw = btns.offsetWidth || 0;
      const bh = btns.offsetHeight || 0;
      const targetX = chartW - rightGap + pad;
      const targetY = chartH - bottomGap + pad;
      const clampedX = Math.min(Math.max(pad, targetX), chartW - bw - pad);
      const clampedY = Math.min(Math.max(pad, targetY), chartH - bh - pad);
      btns.style.right = '20px';
      btns.style.bottom = '20px';
      /*
      btns.style.left = clampedX + 20 + 'px';
      btns.style.top  = clampedY + 'px'; */
      btns.style.visibility = (lastOption.__empty || layoutIsNarrow()) ? 'hidden' : 'visible';
    }

    // 左上角气泡：通常贴左上，但在极窄情况下也做一次夹持，防止超出容器
    if (bubble){
      // 确保 fixed 定位（避免被 #chart 的 overflow 裁剪）
      bubble.style.position = 'fixed';

      const bw2 = bubble.offsetWidth  || 0;
      const bh2 = bubble.offsetHeight || 0;

      // 首次定位（未拖拽过）：贴左上，避免出界
      if (!bubbleUserMoved){
        const preferredX = left + 2;
        const preferredY = top  + 2;
        const vw = window.innerWidth  || document.documentElement.clientWidth  || chartW;
        const vh = window.innerHeight || document.documentElement.clientHeight || chartH;
        const bx = Math.min(Math.max(pad, preferredX), Math.max(pad, vw - bw2 - pad));
        const by = Math.min(Math.max(pad, preferredY), Math.max(pad, vh - bh2 - pad));
        bubble.style.left = bx + 'px';
        bubble.style.top  = by + 'px';
        bubble.style.right  = 'auto';
        bubble.style.bottom = 'auto';
        bubblePos.left = bx; bubblePos.top = by;
      } else {
        // 已拖拽：仅在窗口/全屏变化时进行一次夹持，防止跑出屏幕
        const vw = window.innerWidth  || document.documentElement.clientWidth  || chartW;
        const vh = window.innerHeight || document.documentElement.clientHeight || chartH;
        const bx = Math.min(Math.max(pad, bubblePos.left || 0), Math.max(pad, vw - bw2 - pad));
        const by = Math.min(Math.max(pad, bubblePos.top  || 0), Math.max(pad, vh - bh2 - pad));
        bubble.style.left = Math.round(bx) + 'px';
        bubble.style.top  = Math.round(by) + 'px';
        bubble.style.right  = 'auto';
        bubble.style.bottom = 'auto';
        bubblePos.left = bx; bubblePos.top = by;
      }

      bubble.style.visibility = (showFitCurves && !lastOption.__empty) ? 'visible' : 'hidden';

      const unit = (currentXModeFromPayload(lastPayload) === 'rpm') ? 'RPM' : 'dB';
      const unitSpan = bubble.querySelector('#fitXUnit');
      if (unitSpan) unitSpan.textContent = unit;
    }

     // 窄屏提示小字：右下角（grid 内部，避免与 legend 重叠）
      const hint = ensureNarrowHint();
      const narrow = layoutIsNarrow();
      if (narrow && !lastOption.__empty) {
        // 放在坐标网格右下角，上移一点避开 X 轴刻度
        const x = chartW - rightGap - (hint.offsetWidth || 0) - 6;
        const y = chartH - bottomGap - 14;
        hint.style.left = Math.max(2, x) + 'px';
        hint.style.top  = Math.max(2, y) + 'px';
        hint.style.visibility = 'visible';
      } else {
        hint.style.visibility = 'hidden';
      }
  }

  function bindPointerDrag(){
    const handle = document.getElementById('fitPointerHandle');
    if (!handle) return;

    let dragging=false, startX=0, baseX=0, activePointerId=null;

    function measureGrid(){
      if (!lastOption) return { left:40, right: (chart ? chart.getWidth() - 260 : 800), top: 60, height: 300 };
      const grid = lastOption.grid || { left:40, right: 260, top: 60, bottom: 40 };
      const chartW = chart ? chart.getWidth() : 800;
      const chartH = chart ? chart.getHeight() : 600;
      const left = (typeof grid.left==='number') ? grid.left : 40;
      const rightGap = (typeof grid.right==='number') ? grid.right : 260;
      const top = (typeof grid.top==='number') ? grid.top : 60;
      const bottomGap = (typeof grid.bottom==='number') ? grid.bottom : 40;
      const right = chartW - rightGap;
      const height = chartH - top - bottomGap;
      return { left, right, top, height };
    }

    function onDown(e){
      if (e.button !== undefined && e.button !== 0) return;
      dragging = true;
      activePointerId = e.pointerId ?? null;
      startX = e.clientX;
      const ptr = document.getElementById('fitPointer');
      baseX = parseFloat(ptr?.style.left || '0');
      handle.style.cursor = 'grabbing';
      try { if (activePointerId != null) handle.setPointerCapture(activePointerId); } catch(_){}
      e.preventDefault?.();
    }
    function onMove(e){
      if (!dragging) return;
      const grid = measureGrid();
      const dx = e.clientX - startX;
      let x = baseX + dx;
      x = Math.max(grid.left, Math.min(x, grid.right));
      const ptr = document.getElementById('fitPointer');
      ptr.style.left = x + 'px';

      // 像素 -> 数据 x（轴一维转换）
      const xVal = pxToDataX(x);
      const mode = currentXModeFromPayload(lastPayload);
      if (Number.isFinite(xVal)) {
        xQueryByMode[mode] = clampXDomain(xVal);
        // 实时同步输入与列表
        syncBubbleInput();
        if (showFitCurves) refreshFitBubble();
      }
    }
    function onUp(){
      if (!dragging) return;
      dragging=false;
      handle.style.cursor = 'grab';
      try { if (activePointerId != null) handle.releasePointerCapture(activePointerId); } catch(_){}
      activePointerId=null;
    }
    function onCancel(){
      if (!dragging) return;
      dragging=false;
      handle.style.cursor = 'grab';
      try { if (activePointerId != null) handle.releasePointerCapture(activePointerId); } catch(_){}
      activePointerId=null;
    }

    handle.addEventListener('pointerdown', onDown);
    window.addEventListener('pointermove', onMove, { passive:true });
    window.addEventListener('pointerup', onUp, { passive:true });
    window.addEventListener('pointercancel', onCancel);
    window.addEventListener('blur', onCancel);
  }

  function repaintPointer(){
    const ptr = document.getElementById('fitPointer');
    if (!ptr || !lastOption) return;
    if (!showFitCurves || lastOption.__empty) { ptr.style.visibility = 'hidden'; return; }

    const grid = lastOption.grid || { left:40, right: 260, top: 60, bottom: 40 };
    const chartW = chart ? chart.getWidth() : 800;
    const chartH = chart ? chart.getHeight() : 600;
    const left = (typeof grid.left==='number') ? grid.left : 40;
    const rightGap = (typeof grid.right==='number') ? grid.right : 260;
    const top = (typeof grid.top==='number') ? grid.top : 60;
    const bottomGap = (typeof grid.bottom==='number') ? grid.bottom : 40;
    const height = chartH - top - bottomGap;

    const mode = currentXModeFromPayload(lastPayload);
    if (xQueryByMode[mode] == null) {
      const [vx0, vx1] = getVisibleXRange();
      xQueryByMode[mode] = (vx0 + vx1) / 2;
    }
    clampXQueryIntoVisibleRange();

    // 数据 -> 像素
    const xPixel = dataToPxX(xQueryByMode[mode]);

    ptr.style.left = xPixel + 'px';
    ptr.style.top = top + 'px';
    ptr.style.height = height + 'px';
    ptr.style.visibility = 'visible';

    // 同步输入框与列表
    syncBubbleInput();
    if (showFitCurves) refreshFitBubble();
  }

  function syncBubbleInput(){
    const inp = document.getElementById('fitXInput');
    if (!inp) return;
    const mode = currentXModeFromPayload(lastPayload);
    const val = Number(xQueryByMode[mode]);
    const rounded = (mode === 'noise_db') ? Number(val.toFixed(1)) : Math.round(val);
    inp.value = String(rounded);

    const [vx0, vx1] = getVisibleXRange();
    inp.setAttribute('min', String(Math.floor(vx0)));
    inp.setAttribute('max', String(Math.ceil(vx1)));
    inp.setAttribute('step', (mode === 'noise_db') ? '0.1' : '1');
  }

  function onBubbleInputLive(){
    const inp = document.getElementById('fitXInput');
    if (!inp) return;
    const mode = currentXModeFromPayload(lastPayload);
    const raw = Number(inp.value);
    if (!Number.isFinite(raw)) return;
    xQueryByMode[mode] = clampXDomain(raw);
    clampXQueryIntoVisibleRange();

    // 数据 -> 像素（轴一维转换），实时移动指针
    const xPixel = dataToPxX(xQueryByMode[mode]);
    const ptr = document.getElementById('fitPointer');
    if (ptr && Number.isFinite(xPixel)) ptr.style.left = xPixel + 'px';

    if (showFitCurves) refreshFitBubble();
  }
  function onBubbleInputCommit(){
    repaintPointer();
    refreshFitBubble();
  }

  // refreshFitBubble：在风量后追加以第一名为基准的百分比（右对齐，含括号）
  function refreshFitBubble(){
    const bubble = document.getElementById('fitBubble');
    if (!bubble || !showFitCurves || !lastPayload || !chart) return;
    const rowsEl = bubble.querySelector('#fitBubbleRows');
    const mode = currentXModeFromPayload(lastPayload);
    const x = xQueryByMode[mode];
    if (x == null) return;

    const sList = Array.isArray(lastPayload?.chartData?.series) ? lastPayload.chartData.series : [];
    ensureFitModels(sList, mode);

    const opt = chart.getOption() || {};
    const selMap = (opt.legend && opt.legend[0] && opt.legend[0].selected) || {};
    const items = [];
    sList.forEach(s => {
      const visible = (selMap[s.name] !== false);
      if (!visible) return;
      const model = fitModelsCache[mode].get(s.name);
      if (!model || model.x0 == null || model.x1 == null) return;

      // NEW: x 越界则判为“无值”
      const x0 = Math.min(model.x0, model.x1);
      const x1 = Math.max(model.x0, model.x1);
      let y = NaN;
      if (x >= x0 && x <= x1) {
        y = evalModelY(model, x);
      }
      items.push({ name: s.name, color: s.color, y });
    });

    const fmt = (v)=> Math.round(v);

    // NEW: 仅用“有值”的条目决定排序与百分比基准
    const withVal = items.filter(it => Number.isFinite(it.y)).sort((a,b)=> b.y - a.y);
    const noVal   = items.filter(it => !Number.isFinite(it.y));

    const base = (withVal.length && withVal[0].y > 0) ? withVal[0].y : 0;
    const pctVal = (v)=> (Number.isFinite(v) && base > 0) ? Math.round((v / base) * 100) : null;

    const valTexts = items.map(it => Number.isFinite(it.y) ? `${fmt(it.y)} CFM` : '-');
    const maxValChars = valTexts.reduce((m,s)=>Math.max(m, s.length), 1);
    const pctWidthCh = 6; // "(100%)"

    // NEW: 拼接“有值”在前、“无值”在后（显示 '-'）
    const ordered = withVal.concat(noVal);
    rowsEl.innerHTML = ordered.map(it => {
      const has = Number.isFinite(it.y);
      const valText = has ? `${fmt(it.y)} CFM` : '-';
      const pct = has ? pctVal(it.y) : null;
      const pctText = (pct==null) ? '-' : `(${pct}%)`;
      return `
        <div class="row">
          <span class="dot" style="background:${it.color}"></span>
          <span>${it.name}</span>
          <span style="margin-left:auto; display:inline-flex; align-items:center; gap:8px;">
            <span style="min-width:${maxValChars}ch; text-align:right; font-weight:800; font-variant-numeric:tabular-nums;">${valText}</span>
            <span style="width:${pctWidthCh}ch; text-align:right; font-variant-numeric:tabular-nums;">${pctText}</span>
          </span>
        </div>
      `;
    }).join('');
  }

  function ensureFitModels(sList, xMode){
    const models = fitModelsCache[xMode];

    sList.forEach(s => {
      if (models.has(s.name)) return;

      // 取原始点并清洗：升序 + 合并重复 x（y 取均值）
      const xsRaw = (s[xMode] || []).map(Number);
      const ysRaw = (s.airflow || []).map(Number);
      const pairs = [];
      const n = Math.min(xsRaw.length, ysRaw.length);
      for (let i=0;i<n;i++){
        const x = xsRaw[i], y = ysRaw[i];
        if (Number.isFinite(x) && Number.isFinite(y)) pairs.push([x, y]);
      }
      if (!pairs.length) return;

      pairs.sort((a,b)=> a[0]-b[0]);
      const xs = [], ys = [];
      for (let i=0;i<pairs.length;i++){
        const [x,y] = pairs[i];
        if (xs.length && Math.abs(x - xs[xs.length-1]) < 1e-9){
          ys[ys.length-1] = (ys[ys.length-1] + y) / 2;
        } else {
          xs.push(x); ys.push(y);
        }
      }

      const U = xs.length;
      const x0 = xs[0], x1 = xs[U-1];

      if (U === 1){
        models.set(s.name, { type:'linear', a: ys[0], b: 0, x0, x1: x0 + 1 });
        return;
      }

      if (xMode === 'rpm'){
        // 一次直线（单调非降：b<0 夹到 0）
        const { a, b: bRaw } = olsLinear(xs, ys);
        const b = Math.max(0, Number.isFinite(bRaw) ? bRaw : 0);
        models.set(s.name, { type:'linear', a, b, x0, x1 });
        return;
      }

      // 噪音：二次 vs 对数，取 SSE 更小者
      let best = null;

      const q = olsQuadratic(xs, ys);
      if (q){
        const sseQ = xs.reduce((acc, xv, i)=>{ const r = ys[i] - (q.a + q.b*xv + q.c*xv*xv); return acc + r*r; }, 0);
        best = { type:'quad', a:q.a, b:q.b, c:q.c, sse:sseQ };
      }

      const lg = olsLog(xs, ys);
      if (lg){
        const sseL = xs.reduce((acc, xv, i)=>{ const r = ys[i] - (lg.a + lg.b*Math.log(Math.max(1e-9, xv - lg.shift))); return acc + r*r; }, 0);
        if (!best || sseL < best.sse) best = { type:'log', a:lg.a, b:lg.b, shift:lg.shift, sse:sseL };
      }

      if (!best){
        const { a, b } = olsLinear(xs, ys);
        models.set(s.name, { type:'linear', a, b: Math.max(0,b), x0, x1 });
        return;
      }

      // 存储所选模型参数（渲染时按公式采样）
      if (best.type === 'quad') {
        models.set(s.name, { type:'quad', a:best.a, b:best.b, c:best.c, x0, x1 });
      } else {
        models.set(s.name, { type:'log', a:best.a, b:best.b, shift:best.shift, x0, x1 });
      }
    });
  }

  function computeSampleCount(widthPx){
    const n = Math.round(widthPx / 1.5);
    return Math.max(200, Math.min(1200, n));
  }

  function resampleSingle(model, xmin, xmax, count /* tension ignored */){
    const n = Math.max(2, count|0);
    const pts = [];
    const x0 = Math.max(xmin, model.x0 ?? xmin);
    const x1 = Math.min(xmax, model.x1 ?? xmax);
    for (let i=0;i<n;i++){
      const t = i/(n-1);
      const x = x0 + (x1 - x0) * t;
      const y = evalModelY(model, x);
      pts.push({ x, y });
    }
    return pts;
  }

  // ====== 简单曲线拟合工具（直线/二次/对数）======

  function evalModelY(model, x){
    if (!model) return NaN;
    switch (model.type) {
      case 'linear':
        return model.a + model.b * x;
      case 'quad':
        return model.a + model.b * x + model.c * x * x;
      case 'log':
        return model.a + model.b * Math.log(Math.max(1e-9, x - model.shift));
      default:
        return NaN;
    }
  }

  // 直线 OLS：y = a + b x
  function olsLinear(xs, ys){
    const n = xs.length;
    let sumx=0,sumy=0,sumxx=0,sumxy=0;
    for (let i=0;i<n;i++){ const x=xs[i], y=ys[i]; sumx+=x; sumy+=y; sumxx+=x*x; sumxy+=x*y; }
    const denom = n*sumxx - sumx*sumx;
    let b = (Math.abs(denom) > 1e-12) ? (n*sumxy - sumx*sumy)/denom : 0;
    let a = (sumy - b*sumx)/n;
    return { a, b };
  }

  // 二次 OLS：y = a + b x + c x^2  -> 解 3x3 正规方程
  function olsQuadratic(xs, ys){
    const n = xs.length;
    let S1=0,Sx=0,Sxx=0,Sxxx=0,Sxxxx=0,Sy=0,Sxy=0,Sxxy=0;
    for (let i=0;i<n;i++){
      const x = xs[i], y = ys[i];
      const x2 = x*x, x3 = x2*x, x4 = x2*x2;
      S1   += 1;
      Sx   += x;
      Sxx  += x2;
      Sxxx += x3;
      Sxxxx+= x4;
      Sy   += y;
      Sxy  += x*y;
      Sxxy += x2*y;
    }
    const M = [
      [ S1,   Sx,   Sxx  ],
      [ Sx,   Sxx,  Sxxx ],
      [ Sxx,  Sxxx, Sxxxx ]
    ];
    const b = [ Sy, Sxy, Sxxy ];
    const sol = solve3x3(M, b);
    if (!sol) return null;
    return { a: sol[0], b: sol[1], c: sol[2] };
  }

  // 对数 OLS：y = a + b ln(x - xmin + 1)（保证自变量>0）
  function olsLog(xs, ys){
    const n = xs.length;
    const xmin = Math.min.apply(null, xs);
    const shift = xmin - 1; // ln(x - shift) == ln(x - xmin + 1)
    let sumz=0,sumzz=0,sumy=0,sumzy=0;
    for (let i=0;i<n;i++){
      const z = Math.log(Math.max(1e-9, xs[i] - shift));
      const y = ys[i];
      sumz += z; sumzz += z*z; sumy += y; sumzy += z*y;
    }
    const denom = n*sumzz - sumz*sumz;
    if (Math.abs(denom) < 1e-12) return null;
    const b = (n*sumzy - sumz*sumy)/denom;
    const a = (sumy - b*sumz)/n;
    return { a, b, shift };
  }

  // 3x3 高斯消元
  function solve3x3(M, b){
    const A = [M[0].slice(), M[1].slice(), M[2].slice()];
    const y = b.slice();
    for (let i=0;i<3;i++){
      // 选主元
      let piv=i; for (let r=i+1;r<3;r++) if (Math.abs(A[r][i])>Math.abs(A[piv][i])) piv=r;
      if (Math.abs(A[piv][i])<1e-12) return null;
      if (piv!==i){ const t=A[i]; A[i]=A[piv]; A[piv]=t; const ty=y[i]; y[i]=y[piv]; y[piv]=ty; }
      const div=A[i][i];
      for (let c=i;c<3;c++) A[i][c]/=div; y[i]/=div;
      for (let r=i+1;r<3;r++){ const f=A[r][i]; for (let c=i;c<3;c++) A[r][c]-=f*A[i][c]; y[r]-=f*y[i]; }
    }
    const x = new Array(3);
    for (let i=2;i>=0;i--){ let s=y[i]; for (let c=i+1;c<3;c++) s-=A[i][c]*x[c]; x[i]=s; }
    return x;
  }

  function clampXDomain(val){
    if (!lastOption) return val;
    const xAxis = lastOption.xAxis || {};
    const xmin = Number(xAxis.min); const xmax = Number(xAxis.max);
    if (!Number.isFinite(xmin) || !Number.isFinite(xmax)) return val;
    return Math.max(xmin, Math.min(val, xmax));
  }

  function getVisibleXRange(){
    if (!lastOption) return [0,1];
    const xAxis = lastOption.xAxis || {};
    const xmin = Number(xAxis.min); const xmax = Number(xAxis.max);
    let vmin = xmin, vmax = xmax;
    const opt = chart.getOption() || {};
    const dz = (opt.dataZoom||[]).find(z => z.xAxisIndex === 0 || (z.xAxisIndex||0)===0) || null;
    if (dz && typeof dz.start === 'number' && typeof dz.end === 'number') {
      const span = xmax - xmin;
      vmin = xmin + span * (dz.start/100);
      vmax = xmin + span * (dz.end/100);
    }
    return [vmin, vmax];
  }

  function clampXQueryIntoVisibleRange(){
    const mode = currentXModeFromPayload(lastPayload);
    if (xQueryByMode[mode] == null) return;
    const [vmin, vmax] = getVisibleXRange();
    if (xQueryByMode[mode] < vmin) xQueryByMode[mode] = vmin;
    if (xQueryByMode[mode] > vmax) xQueryByMode[mode] = vmax;
  }

  // 消息通信（父页面 -> iframe）
  window.addEventListener('message', (e)=>{
    if (e.origin !== window.location.origin) return;
    const { type, payload } = e.data || {};
    if (type==='chart:update' && payload) render(payload);
    if (type==='chart:resize' && chart) {
      const nowNarrow = layoutIsNarrow();
      if (lastIsNarrow === null) lastIsNarrow = nowNarrow;

      if (nowNarrow !== lastIsNarrow) {
        lastIsNarrow = nowNarrow;
        if (lastPayload) render(lastPayload);
        else chart.resize();
      } else {
        chart.resize();
        if (lastOption) {
          const { x, y, visible } = computePrefixCenter(lastOption);
          placeAxisOverlayAt(x, y, visible && !lastOption.__empty);
          placeFitUI();
          repaintPointer();
        }
      }
    }
  });

  document.addEventListener('DOMContentLoaded', init);

})();
</script>
</body>
</html>