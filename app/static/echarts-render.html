<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Chart Renderer</title>
  <style>
    html,body{height:100%;margin:0}
    #chart{width:100%;height:100%; position: relative; overflow: hidden;}

    /* 主题变量 */
    :root{
      --bg-secondary:#ffffff;
      --border-color:#e5e7eb;
      --text-primary:#1f2937;
      --text-secondary:#6b7280;
      --accent:#2563eb;
      --accent-weak:#93c5fd;
      --ok:#16a34a;
      --ok-pressed:#15803d;
      --shadow:0 6px 20px rgba(0,0,0,0.12);
      --shadow-strong:0 8px 24px rgba(0,0,0,0.18);
    }
    [data-theme="dark"]{
      --bg-secondary:#1f2937;
      --border-color:#374151;
      --text-primary:#f3f4f6;
      --text-secondary:#9ca3af;
      --accent:#60a5fa;
      --accent-weak:#bfdbfe;
      --ok:#16a34a;
      --ok-pressed:#15803d;
      --shadow:0 6px 20px rgba(0,0,0,0.35);
      --shadow-strong:0 8px 24px rgba(0,0,0,0.45);
    }

    /* （保留原样式） */
    .chart-xaxis-overlay{ position:absolute; z-index:2147483641; visibility:hidden; transform: translate(-65%, -37%); }
    .switch-container { position:relative; width:76px; height:32px; }
    .switch-track { width:100%; height:100%; background:var(--border-color); border-radius:12px; position:relative; overflow:hidden; }
    .switch-track::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      pointer-events: none;
      background: linear-gradient(to bottom, rgba(255,255,255,.22), rgba(255,255,255,0));
      box-shadow: inset 0 2px 6px rgba(0,0,0,.10), inset 0 -1px 2px rgba(0,0,0,.05);
    }
    [data-theme="dark"] .switch-track::before {
      background: linear-gradient(to bottom, rgba(255,255,255,.08), rgba(255,255,255,0));
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.45), inset 0 -1px 2px rgba(0,0,0,0.35);
    }
    .switch-slider {
      position:absolute; width:24px; height:100%; background:var(--text-secondary); border-radius:12px;
      left:0; top:0; transition:transform .25s ease; box-shadow:0 2px 5px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.25), inset 0 -1px 0 rgba(0,0,0,.25); cursor:grab;
    }
    .switch-label { cursor: pointer; position:absolute; top:46%; transform:translateY(-50%); font-weight:600; font-size:20px; color:var(--text-primary); white-space:nowrap; pointer-events: none; user-select: none; }
    .switch-label-left { right:calc(100% + 5px); }
    .switch-label-right { left:calc(100% + 5px); }
    .chart-xaxis-overlay,.switch-container,.switch-track,.switch-slider { touch-action: none; }

    .fit-buttons{ position: absolute; z-index: 2147483645; visibility: hidden; display: flex; gap: 6px; pointer-events: auto; }
    .fit-buttons .btn{ appearance: none; border: 1px solid var(--border-color); background: var(--bg-secondary); color: var(--text-primary); font-size: 12px; font-weight: 700; padding: 6px 8px; border-radius: 8px; cursor: pointer; user-select: none; line-height: 1; box-shadow: var(--shadow); transition: transform .02s ease-in-out, background-color .15s ease, color .15s ease; }
    .fit-buttons .btn:active{ transform: translateY(1px); }
    .fit-buttons .btn.active{ background: var(--ok); color: #fff; border-color: var(--ok); }
    .fit-buttons .btn.active:active{ background: var(--ok-pressed); }

    .fit-bubble{ position: fixed; z-index: 2147483645; visibility: hidden; min-width: 260px; max-width: 420px; max-height: 60vh; overflow: auto; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; box-shadow: var(--shadow-strong); padding: 10px 12px; cursor: grab; touch-action: none; }
    .fit-bubble.dragging{ cursor: grabbing; }
    .fit-bubble .head{ display:flex; align-items:center; gap:10px; margin-bottom: 6px; }
    .fit-bubble .title{ font-weight: 800; color: var(--text-primary); font-size: 13px; line-height: 1.2; white-space: nowrap; }
    .fit-bubble .x-input{ margin-left:auto; display:flex; align-items:center; gap:6px; font-size:12px; color: var(--text-secondary); white-space: nowrap; }
    .fit-bubble input[type="number"]{ width: 10ch; font-size: 12px; padding: 4px 6px; border: 1px solid var(--border-color); border-radius: 8px; background: transparent; color: var(--text-primary); outline: none; }
    .fit-bubble .row{ display:flex; align-items:center; gap:8px; margin: 4px 0; color: var(--text-primary); font-size: 13px; }
    .fit-bubble .row .dot{ width:10px; height:10px; border-radius:50%; flex:0 0 auto; }
    .fit-bubble .hint{ color: var(--text-secondary); font-size: 11px; margin-top: 6px; }

    .fit-pointer{ position: absolute; z-index: 2147483644; visibility: hidden; pointer-events: none; }
    .fit-pointer .line{ position:absolute; top:0; bottom:0; width: 2px; transform: translateX(-1px); background: var(--accent); opacity: 0.95; }
    .fit-pointer .handle{ position:absolute; bottom:-22px; left:-8px; width:16px; height:24px; border-radius:4px; background: var(--accent); box-shadow: var(--shadow); cursor: grab; touch-action: none; pointer-events: auto; }
    .fit-pointer .handle::after{ content:""; position:absolute; left:50%; transform: translateX(-50%); top:-7px; width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 9px solid var(--accent); }

    .fit-narrow-hint{ position:absolute; z-index:2147483643; font-size:11px; color: var(--text-secondary); pointer-events:none; user-select:none; white-space:nowrap; }

    .share-btn { position:absolute; z-index:2147483642; visibility:hidden; width:32px; height:32px; border-radius:50%; background:var(--bg-secondary); border:1px solid var(--border-color); display:flex; align-items:center; justify-content:center; cursor:pointer; box-shadow:var(--shadow); transition:background .2s,border-color .2s,transform .2s; color:var(--text-primary); font-size:16px; user-select:none; }
    .share-btn:hover { background: var(--accent); color:#fff; border-color: var(--accent); }
    .share-toast { position:fixed; left:50%; top:14px; transform:translateX(-50%) translateY(-8px); background:var(--bg-secondary); color:var(--text-primary); padding:10px 14px; border:1px solid var(--border-color); border-radius:8px; font-size:12px; box-shadow:var(--shadow); opacity:0; transition:opacity .3s, transform .3s; z-index:2147483650; max-width:80vw; line-height:1.4; pointer-events:none; user-select:text; word-break:break-all; white-space:normal; }
    .share-toast.show { opacity:1; transform:translateX(-50%) translateY(0); pointer-events:auto; }
    .share-fail-title { font-weight:700; margin-bottom:4px; display:block; }
    .share-fail-url { font-family:monospace; font-size:12px; word-break:break-all; white-space:normal; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.2/dist/echarts.min.js"></script>
</head>
<body>
  <div id="chart"></div>
<script>
/* =========================================================
   MODULE LAYOUT (高优整理阶段)
   1. 环境 & 全局状态
   2. 工具 & 文本测量缓存
   3. Share 按钮 & Toast
   4. 拟合/曲线状态
   5. 初始化 & 事件绑定（抽取公共刷新函数）
   6. Axis 切换 UI
   7. 渲染主流程 buildOption/render
   8. 拟合 UI/指针/气泡逻辑
   9. 拟合算法 (纯函数段)
   10. Visible range / clamp 工具
   11. 消息通信 (postMessage)
   TODO（后续阶段再做）：
      - 抽离 pointer/fit 刷新 orchestrator
      - 抽离 layoutIsNarrow / fullscreen 适配策略模块
      - 抽离 axis overlay/placement 合并成 updateAxisUI()
========================================================= */

/* ========== 1. 环境 & 全局状态 ========== */
(function () {
  let chart;
  let lastOption = null;
  let lastPayload = null;
  let isFs = false;
  let lastIsNarrow = null;
  let shareBtn = null;
  let shareInitializedFromMeta = false;
  let shareLegendHiddenKeys = null;

  const narrowDeferred = {
    stored: false,
    applied: false,
    showRaw: null,
    showFit: null,
    pointer: { rpm: null, noise_db: null }
  };
  let applyingDeferred = false;

  let bubbleUserMoved = false;
  const bubblePos = { left: null, top: null };

  let xAxisOverride = null;
  let axisSnapSuppressUntil = 0;

  window.__FS_TOGGLE_OFFSET = window.__FS_TOGGLE_OFFSET || { x: 0, y: 0 };
  const TITLE_GLUE = '  -  ';

  function isMobile(){
    return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent)
      || (window.matchMedia && window.matchMedia('(pointer:coarse)').matches);
  }
  function layoutIsNarrow() {
    const w = chart && typeof chart.getWidth === 'function'
      ? chart.getWidth()
      : (typeof window !== 'undefined' ? window.innerWidth : 0);
    let narrow = w < 600;
    if (isFs && isMobile()) narrow = false;
    return narrow;
  }

  /* ========== 2. 工具 & 文本测量缓存 ========== */
  const measureCtx = (function(){
    const c = document.createElement('canvas');
    return c.getContext('2d');
  })();
  function measureText(text, size, weight, family){
    const ctx = measureCtx;
    ctx.font = `${String(weight||400)} ${Number(size||14)}px ${family||'sans-serif'}`;
    const m = ctx.measureText(text || '');
    const width = m.width || 0;
    const ascent = (typeof m.actualBoundingBoxAscent === 'number') ? m.actualBoundingBoxAscent : size * 0.8;
    const descent = (typeof m.actualBoundingBoxDescent === 'number') ? m.actualBoundingBoxDescent : size * 0.2;
    return { width, height: ascent + descent };
  }

  /* ========== 3. Share 按钮 & Toast ========== */
  function ensureShareButton(){
    if (shareBtn) return shareBtn;
    shareBtn = document.createElement('div');
    shareBtn.id='chartShareBtn';
    shareBtn.className='share-btn';
    shareBtn.title='生成分享链接';
    shareBtn.innerHTML='<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12v7a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-7"/><path d="M16 6l-4-4-4 4"/><path d="M12 2v13"/></svg>';
    shareBtn.addEventListener('click', onShareClick);
    document.getElementById('chart').appendChild(shareBtn);
    return shareBtn;
  }
  function hideShareButton(){ if (shareBtn) shareBtn.style.visibility='hidden'; }
  function placeShareButton(option){
    if (!option || option.__empty || !lastPayload?.chartData?.series?.length){
      hideShareButton(); return;
    }
    const btn = ensureShareButton();
    const t = option.title;
    if (!t){ hideShareButton(); return; }
    const size = (t.textStyle && t.textStyle.fontSize) || option.__titleFontSize || 20;
    const weight = (t.textStyle && t.textStyle.fontWeight) || option.__titleFontWeight || 600;
    const family = (t.textStyle && t.textStyle.fontFamily) || option.__titleFamily;
    const m = measureText(t.text, size, weight, family);
    const chartW = chart.getWidth();
    const centerX = chartW/2;
    const leftX = centerX - m.width/2;
    const rightX = leftX + m.width;
    const top = (typeof t.top === 'number') ? t.top : 10;
    const middleY = top + m.height/2;
    btn.style.left = Math.round(rightX + 12)+'px';
    btn.style.top  = Math.round(middleY - 16)+'px';
    btn.style.visibility='visible';
  }
  function getShareToastDiv(){
    let div = document.getElementById('shareToast');
    if (!div){
      div=document.createElement('div');
      div.id='shareToast';
      div.className='share-toast';
      document.body.appendChild(div);
    }
    return div;
  }
  function hideShareToastLater(div, ms){
    clearTimeout(div._t);
    div._t = setTimeout(()=>{
      div.classList.remove('show');
      setTimeout(()=>{ if(!div.classList.contains('show')) div.style.pointerEvents='none'; }, 320);
    }, ms);
  }
  function showShareToast(msg){
    const div = getShareToastDiv();
    div.textContent = msg;
    div.style.pointerEvents='auto';
    div.classList.add('show');
    hideShareToastLater(div, 3200);
  }
  function showShareCopyFail(url){
    const div = getShareToastDiv();
    const safeUrl = url;
    div.innerHTML = '<span class="share-fail-title">自动复制失败，请手动复制链接：</span><span class="share-fail-url">'+safeUrl+'</span>';
    div.style.pointerEvents='auto';
    div.classList.add('show');
    hideShareToastLater(div, 12000);
  }
  async function onShareClick(){
    try{
      if (!lastPayload || !lastPayload.chartData) return;
      const s = lastPayload.chartData.series || [];
      if (!s.length) return;
      const xMode = currentXModeFromPayload(lastPayload);
      let pointerVal = null;
      if (xQueryByMode[xMode] != null){
        pointerVal = xQueryByMode[xMode];
      } else {
        const [vx0,vx1] = getVisibleXRange();
        pointerVal = (vx0 + vx1)/2;
      }
      let hiddenIndexes = [];
      try {
        const opt = chart.getOption() || {};
        const sel = (opt.legend && opt.legend[0] && opt.legend[0].selected) || {};
        s.forEach((series, idx)=>{
          if (sel[series.name] === false) hiddenIndexes.push(idx);
        });
      } catch(_){}
      const colorIndices = s.map(it => (typeof it.color_index === 'number') ? it.color_index : null);
      const fans = s.map(it => ({ m: it.model_id, c: it.condition_id }));
      const body = {
        fans,
        x_axis_type: xMode,
        show_raw: showRawCurves,
        show_fit: showFitCurves,
        pointer: pointerVal,
        legend_hidden: hiddenIndexes,
        color_indices: colorIndices
      };
      const resp = await fetch('/api/create_share',{
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify(body)
      }).then(r=>r.json());
      if (!resp.success){ showShareToast('分享失败：'+(resp.error||'')); return; }
      const url = resp.url;
      try {
        await navigator.clipboard.writeText(url);
        showShareToast('分享链接已复制到剪贴板');
      } catch {
        showShareCopyFail(url);
      }
    }catch(e){
      showShareToast('异常：'+e.message);
    }
  }

  /* ========== 4. 拟合/曲线状态 ========== */
  const FIT_ALGO_NAME = '趋势拟合';
  let showRawCurves = true;
  let showFitCurves = false;
  const FIT_TENSION = 0.85;
  const xQueryByMode = { rpm: null, noise_db: null };
  const fitModelsCache = { rpm: new Map(), noise_db: new Map() };
  const fitSamplesCache = { rpm: new Map(), noise_db: new Map(), sampleCount: 0, domain: { rpm:[null,null], noise_db:[null,null] } };
  let fitUIInstalled = false;

  /* ========== 5. 初始化 & 公共刷新 ========== */
  function init() {
    chart = echarts.init(document.getElementById('chart'), null, {
      renderer:'canvas',
      devicePixelRatio: window.devicePixelRatio || 1
    });
    chart.on('finished', () => {
      if (lastOption && !lastOption.__empty) placeShareButton(lastOption);
    });

    window.addEventListener('resize', handleLayoutMutation);
    document.addEventListener('fullscreenchange', () => {
      isFs = !!document.fullscreenElement;
      if (!isFs) {
        if (screen.orientation && screen.orientation.unlock) {
          try { screen.orientation.unlock(); } catch(_) {}
        }
      }
      handleLayoutMutation();
    });

    chart.on('legendselectchanged', () => { if (showFitCurves) refreshFitBubble(); });
    chart.on('dataZoom', () => {
      clampXQueryIntoVisibleRange();
      repaintPointer();
      if (showFitCurves) refreshFitBubble();
    });
  }

  // 合并原多处重复：窗口尺寸 / 全屏变化后需要的统一处理
  function handleLayoutMutation(){
    if (!chart) return;
    const nowNarrow = layoutIsNarrow();
    if (lastIsNarrow === null) lastIsNarrow = nowNarrow;

    if (nowNarrow !== lastIsNarrow) {
      lastIsNarrow = nowNarrow;
      if (lastPayload) render(lastPayload);
      else chart.resize();
    } else {
      chart.resize();
      if (lastOption) {
        const { x, y, visible } = computePrefixCenter(lastOption);
        placeAxisOverlayAt(x, y, visible && !lastOption.__empty);
        placeFitUI();
        repaintPointer();
      }
    }
  }

  /* ========== 6. Axis 切换 UI（保留原逻辑，后续再抽象） ========== */
  function updateAxisSwitchPosition(opts = {}) {
    const { force = false, animate = false } = opts;
    if (!force && performance.now() < axisSnapSuppressUntil) return;
    const track  = document.getElementById('xAxisSwitchTrack');
    const slider = document.getElementById('xAxisSwitchSlider');
    if (!track || !slider) return;

    const sliderWidth = slider.offsetWidth || 0;
    const trackWidth  = track.offsetWidth || 0;
    const maxX = Math.max(0, trackWidth - sliderWidth);

    const currType = currentXModeFromPayload(lastPayload);
    const toNoise  = (currType === 'noise_db');

    slider.style.transition = animate ? 'transform .25s ease' : 'none';
    slider.style.transform  = `translateX(${toNoise ? maxX : 0}px)`;
    track.setAttribute('aria-checked', String(toNoise));
  }
  function ensureAxisOverlay(){
    let overlay = document.getElementById('chartXAxisOverlay');
    if (!overlay){
      overlay = document.createElement('div');
      overlay.id = 'chartXAxisOverlay';
      overlay.className = 'chart-xaxis-overlay';
      overlay.setAttribute('aria-label','X轴切换');
      overlay.innerHTML = `
        <div class="switch-container" id="xAxisSwitchContainer">
          <div class="switch-track" id="xAxisSwitchTrack">
            <div class="switch-slider" id="xAxisSwitchSlider">
              <span class="switch-label switch-label-right">转速</span>
              <span class="switch-label switch-label-left">噪音</span>
            </div>
          </div>
        </div>`;
      document.getElementById('chart').appendChild(overlay);
      bindXAxisSwitch();
      requestAnimationFrame(() => updateAxisSwitchPosition({ force: true, animate: false }));
    }
    return overlay;
  }
  function bindXAxisSwitch(){
    const xAxisSwitchTrack = document.getElementById('xAxisSwitchTrack');
    const xAxisSwitchSlider = document.getElementById('xAxisSwitchSlider');
    if (!xAxisSwitchTrack || !xAxisSwitchSlider) return;

    let sliderWidth = 0, trackWidth = 0, maxX = 0;
    let dragging = false, dragMoved = false, startX = 0, base = 0, activePointerId = null;

    try {
      xAxisSwitchTrack.setAttribute('role', 'switch');
      xAxisSwitchTrack.setAttribute('aria-checked', String((currentXModeFromPayload(lastPayload) || 'rpm') !== 'rpm'));
    } catch(_) {}

    function measure() {
      sliderWidth = xAxisSwitchSlider.offsetWidth || 0;
      trackWidth  = xAxisSwitchTrack.offsetWidth || 0;
      maxX = Math.max(0, trackWidth - sliderWidth);
    }
    function pos(type, animate = true) {
      const toNoise = (type === 'noise_db' || type === 'noise');
      const x = toNoise ? maxX : 0;
      xAxisSwitchSlider.style.transition = animate ? 'transform .25s ease' : 'none';
      xAxisSwitchSlider.style.transform  = `translateX(${x}px)`;
      xAxisSwitchTrack.setAttribute('aria-checked', String(toNoise));
    }
    function protectSliderAnimationWindow() {
      axisSnapSuppressUntil = performance.now() + 360;
    }
    xAxisSwitchSlider.addEventListener('transitionend', () => { axisSnapSuppressUntil = 0; });

    function applyType(newType) {
      const normalized = (newType === 'noise') ? 'noise_db' : newType;
      if (normalized !== 'rpm' && normalized !== 'noise_db') return;
      if (xAxisOverride === normalized) return;
      xAxisOverride = normalized;
      try { localStorage.setItem('x_axis_type', normalized); } catch(_) {}
      pos(normalized, true);
      protectSliderAnimationWindow();
      if (lastPayload) render(lastPayload);
      try {
        window.parent.postMessage({
          type:'chart:xaxis-type-changed',
            payload:{ x_axis_type: normalized, fullscreen: !!document.fullscreenElement, source:'iframe' }
        }, window.location.origin);
      } catch(_){}
    }
    function nearestType() {
      const m = new DOMMatrix(getComputedStyle(xAxisSwitchSlider).transform);
      const cur = m.m41 || 0;
      return cur > maxX / 2 ? 'noise_db' : 'rpm';
    }
    function onPointerDown(e) {
      if (e.button !== undefined && e.button !== 0) return;
      measure(); dragging = true; dragMoved = false;
      activePointerId = e.pointerId ?? null;
      startX = e.clientX;
      const m = new DOMMatrix(getComputedStyle(xAxisSwitchSlider).transform);
      base = m.m41 || 0;
      xAxisSwitchSlider.style.transition = 'none';
      try { if (activePointerId != null) xAxisSwitchSlider.setPointerCapture(activePointerId); } catch(_){}
      e.preventDefault?.();
    }
    function onPointerMove(e) {
      if (!dragging) return;
      const dx = e.clientX - startX;
      if (!dragMoved && Math.abs(dx) > 2) dragMoved = true;
      let x = base + dx;
      x = Math.max(0, Math.min(x, maxX));
      xAxisSwitchSlider.style.transform = `translateX(${x}px)`;
    }
    function finishDrag() {
      if (!dragging) return;
      dragging = false;
      try { if (activePointerId != null) xAxisSwitchSlider.releasePointerCapture(activePointerId); } catch(_){}
      activePointerId = null;
      const newType = nearestType();
      pos(newType, true);
      applyType(newType);
    }
    function cancelDrag() {
      if (!dragging) return;
      dragging = false;
      try { if (activePointerId != null) xAxisSwitchSlider.releasePointerCapture(activePointerId); } catch(_){}
      activePointerId = null;
      pos(currentXModeFromPayload(lastPayload), true);
    }

    xAxisSwitchTrack.addEventListener('click', () => {
      if (dragMoved) { dragMoved = false; return; }
      const curr = currentXModeFromPayload(lastPayload);
      const next = (curr === 'rpm') ? 'noise_db' : 'rpm';
      pos(next, true);
      applyType(next);
    });
    xAxisSwitchTrack.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove, { passive: true });
    window.addEventListener('pointerup', finishDrag, { passive: true });
    window.addEventListener('pointercancel', cancelDrag);
    window.addEventListener('blur', cancelDrag);

    measure();
    pos(currentXModeFromPayload(lastPayload), false);
    window.addEventListener('resize', () => {
      const keep = currentXModeFromPayload(lastPayload);
      measure();
      pos(keep, false);
    });
  }
  function placeAxisOverlayAt(x, y, show){
    const overlay = ensureAxisOverlay();
    const off = window.__FS_TOGGLE_OFFSET || { x: 0, y: 0 };
    overlay.style.left = (x + (Number(off.x)||0)) + 'px';
    overlay.style.top  = (y + (Number(off.y)||0)) + 'px';
    overlay.style.visibility = show ? 'visible' : 'hidden';
    requestAnimationFrame(() => updateAxisSwitchPosition());
  }

  /* ========== 7. 渲染核心（整合重复 setTimeout） ========== */
  function currentXModeFromPayload(payload){
    const inPay = (payload?.chartData?.x_axis_type === 'noise_db' || payload?.chartData?.x_axis_type === 'noise') ? 'noise_db' : 'rpm';
    if (xAxisOverride) return xAxisOverride;
    return inPay;
  }
  function tokens(theme) {
    const dark = (theme||'').toLowerCase()==='dark';
    return {
      fontFamily:'system-ui,-apple-system,"Segoe UI","Helvetica Neue","Microsoft YaHei",Arial,sans-serif',
      axisLabel: dark ? '#d1d5db' : '#4b5563',
      axisName:  dark ? '#9ca3af' : '#6b7280',
      axisLine:  dark ? '#374151' : '#e5e7eb',
      gridLine:  dark ? 'rgba(255,255,255,0.10)' : 'rgba(0,0,0,0.08)',
      tooltipBg: dark ? 'rgba(17,24,39,0.97)' : 'rgba(255,255,255,0.98)',
      tooltipBorder: dark ? '#374151' : '#e5e7eb',
      tooltipText: dark ? '#f3f4f6' : '#1f2937',
      tooltipShadow: dark ? '0 6px 20px rgba(0,0,0,0.35)' : '0 6px 20px rgba(0,0,0,0.12)',
      pagerIcon: dark ? '#93c5fd' : '#2563eb'
    };
  }
  function buildSeries(rawSeries, xMode) {
    let maxAir = 0;
    let minX = +Infinity, maxX = -Infinity;
    const series = rawSeries.map(s => {
      const xArr = (s[xMode] || []).map(Number);
      const yArr = (s.airflow || []).map(Number);
      const tipArr = (xMode === 'rpm' ? s.noise_db : s.rpm) || [];
      const len = Math.min(xArr.length, yArr.length, tipArr.length || xArr.length);
      const data = [];
      for (let i = 0; i < len; i++) {
        const x = xArr[i], y = yArr[i], tip = Number(tipArr[i]);
        if (Number.isFinite(x)) { minX = Math.min(minX, x); maxX = Math.max(maxX, x); }
        if (Number.isFinite(y)) { maxAir = Math.max(maxAir, y); }
        data.push({ value: [x, y], tip });
      }
      return {
        name: s.name,
        type: 'line',
        smooth: true,
        connectNulls: false,
        showSymbol: true,
        symbol: 'circle',
        symbolSize: 8,
        lineStyle: { width: 3, color: s.color },
        itemStyle: { color: s.color },
        label: { show: true, position: 'top', color: 'gray' },
        legendHoverLink: true,
        emphasis: {
          focus: 'series',
          blurScope: 'coordinateSystem',
          lineStyle: { width: 4 },
          itemStyle: { borderWidth: 1.2, shadowColor: 'rgba(0,0,0,0.25)', shadowBlur: 8 },
          label: { show: true }
        },
        blur: {
          lineStyle: { opacity: 0.18 },
          itemStyle: { opacity: 0.18 },
          label: { show: false }
        },
        data
      };
    });
    if (minX === +Infinity) { minX = 0; maxX = 100; }
    if (maxAir <= 0) maxAir = 100;
    const span = Math.max(1, maxX - minX);
    const pad = Math.floor(span * 0.2);
    return { series, xMin: Math.max(minX - pad, 0), xMax: maxX + pad, yMax: Math.ceil(maxAir * 1.4) };
  }

  function buildOption(payload) {
    const { chartData, theme } = payload || {};
    const t = tokens(theme||'light');
    const sList = Array.isArray(chartData?.series) ? chartData.series : [];
    const xMode = currentXModeFromPayload(payload);
    let isNarrow = chart && typeof chart.getWidth === 'function'
      ? (chart.getWidth() < 600)
      : (typeof window !== 'undefined' ? window.innerWidth < 600 : false);
    if (isFs && isMobile()) isNarrow = false;

    // 窄屏保存状态
    if (isNarrow && !narrowDeferred.stored){
      narrowDeferred.showRaw = showRawCurves;
      narrowDeferred.showFit = showFitCurves;
      narrowDeferred.pointer.rpm = xQueryByMode.rpm;
      narrowDeferred.pointer.noise_db = xQueryByMode.noise_db;
      narrowDeferred.stored = true;
    }
    // 窄屏强制只显示原始
    if (isNarrow){
      if (!showRawCurves) showRawCurves = true;
      if (showFitCurves) showFitCurves = false;
    }

    if (!sList.length || (!showRawCurves && !showFitCurves)) {
      const bgColor = (payload && payload.chartBg) || getExportBg();
      toggleFitUI(false);
      return {
        __empty:true,
        backgroundColor: bgColor,
        title:{ text:'请添加数据生成图表', left:'center', top:'middle',
          textStyle:{ color:t.axisLabel, fontFamily:t.fontFamily } },
        toolbox:{  show:false, feature:{ saveAsImage:{ backgroundColor:bgColor, pixelRatio: window.devicePixelRatio || 1 } } },
        tooltip:{ show:false, triggerOn:'none' }
      };
    }

    const built = buildSeries(sList, xMode);
    const xName = xMode==='rpm' ? '转速(RPM)' : '噪音(dB)';
    const titlePrefix = xMode==='rpm' ? '转速' : '噪音';
    const bgColor = (payload && payload.chartBg) || getExportBg();

    const titleTop = 10;
    const titleFontSize = 20;
    const titleFontWeight = 600;
    const titleText = `${titlePrefix}${TITLE_GLUE}风量曲线`;
    const titleMeasure = measureText(titleText, titleFontSize, titleFontWeight, t.fontFamily);
    const gridTop = Math.max(54, titleTop + Math.ceil(titleMeasure.height) + 12);

    const legendReserveRightPx = isNarrow ? 20 : 260;
    const legendReserveBottomPx = isNarrow ? Math.min(320, 50 + (sList.length || 1) * 22) : 40;

    const legendMeta = {};
    sList.forEach(s=>{
      const brand = s.brand || s.brand_name_zh || s.brand_name || '';
      const model = s.model || s.model_name || '';
      const rt    = s.res_type || s.resistance_type_zh || s.resistance_type || s.rt || '';
      const rl    = s.res_loc || s.resistance_location_zh || s.resistance_location || s.rl || '';
      const key   = s.name || [brand, model].filter(Boolean).join(' ') || String(s.key || '');
      legendMeta[key] = { brand, model, rt, rl };
    });
    function desktopLegendFormatter(name){
      const m = legendMeta[name] || {};
      const line1 = [m.brand, m.model].filter(Boolean).join(' ');
      const line2 = [m.rt, m.rl].filter(Boolean).join(' ');
      if (line2) return `{l1|${line1}}\n{l2|${line2}}`;
      return `{l1|${line1||name}}`;
    }
    function mobileLegendFormatter(name){
      const m = legendMeta[name] || {};
      const left = [m.brand, m.model].filter(Boolean).join(' ');
      const right = [m.rt, m.rl].filter(Boolean).join(' ');
      if (right) return `{m1|${left}} {m1|-} {m2|${right}}`;
      return `{m1|${left||name}}`;
    }
    const legendCfg = isNarrow ? {
      type: 'scroll',
      orient: 'vertical',
      left: 20, right: 6, bottom: 6,
      itemWidth: 16, itemHeight: 10, align: 'auto',
      pageIconColor: t.pagerIcon, pageTextStyle: { color: t.axisLabel },
      textStyle: { color: t.axisLabel, fontFamily: t.fontFamily,
        rich: { m1:{ fontSize:13,fontWeight:600,color:t.axisLabel,lineHeight:18 },
                m2:{ fontSize:11,fontWeight:500,color:t.axisName,lineHeight:16 } } },
      formatter: mobileLegendFormatter
    } : {
      type: 'scroll',
      orient: 'vertical',
      right: 80, top: gridTop, bottom: 10,
      itemWidth: 18, itemHeight: 10, itemGap: 16, align: 'auto',
      pageIconColor: t.pagerIcon, pageTextStyle: { color: t.axisLabel },
      textStyle: { color: t.axisLabel, fontFamily: t.fontFamily,
        rich: { l1:{ fontSize:13,fontWeight:600,color:t.axisLabel,lineHeight:18 },
                l2:{ fontSize:11,fontWeight:500,color:t.axisName,lineHeight:14 } } },
      formatter: desktopLegendFormatter
    };
    try {
      const prevSel = chart && chart.getOption && chart.getOption().legend && chart.getOption().legend[0] && chart.getOption().legend[0].selected;
      if (prevSel) legendCfg.selected = prevSel;
    } catch(_){}
    if (shareLegendHiddenKeys){
      const selMap = legendCfg.selected || {};
      sList.forEach(s=>{
        const key = String(s.key || '');
        if (shareLegendHiddenKeys.has(key)){
          selMap[s.name] = false;
        } else {
          if (!(s.name in selMap)) selMap[s.name] = true;
        }
      });
      legendCfg.selected = selMap;
      shareLegendHiddenKeys = null;
    }

    const iconEnter = 'path://M3 10v-7h7M3 3l7 7M21 14v7h-7M21 21l-7-7';
    const iconExit  = 'path://M3 7v7h7M3 14l7-7M21 17v-7h-7M21 10l-7 7';

    const finalSeries = [];
    if (showRawCurves) built.series.forEach(s => finalSeries.push(s));
    if (showFitCurves) {
      ensureFitModels(sList, xMode);
      const width = Math.max(300, chart.getWidth ? chart.getWidth() : 800);
      const sampleCount = computeSampleCount(width);
      if (fitSamplesCache.sampleCount !== sampleCount) fitSamplesCache.sampleCount = sampleCount;
      sList.forEach(s => {
        const model = fitModelsCache[xMode].get(s.name);
        if (!model || model.x0 == null || model.x1 == null) return;
        const sMin = Math.min(model.x0, model.x1);
        const sMax = Math.max(model.x0, model.x1);
        const xmin = Math.max(built.xMin, sMin);
        const xmax = Math.min(built.xMax, sMax);
        if (!(xmax > xmin)) return;
        const pts = resampleSingle(model, xmin, xmax, sampleCount, FIT_TENSION);
        fitSamplesCache[xMode].set(s.name, pts);
        finalSeries.push({
          id: `fit-line:${xMode}:${s.name}`,
          name: s.name,
          type: 'line',
            smooth: false,
            showSymbol: false,
            connectNulls: false,
            data: pts.map(p => [p.x, p.y]),
            lineStyle: { width: 2.5, type:'dashed', color: s.color, opacity: 0.95 },
            itemStyle: { color: s.color },
            legendHoverLink: true,
            emphasis: { focus: 'series', blurScope: 'coordinateSystem', lineStyle: { width: 3.5, opacity: 1 }, itemStyle: { opacity: 1 } },
            blur: { lineStyle: { opacity: 0.2 }, itemStyle: { opacity: 0.2 } },
            silent: false,
            tooltip: { show: false },
            z: 3
        });
      });
    }

    return {
      __empty:false,
      __titlePrefix:titlePrefix,
      __themeTokens:t,
      __titleTop: titleTop,
      __titleFontSize: titleFontSize,
      __titleFontWeight: titleFontWeight,
      __titleFamily: t.fontFamily,
      backgroundColor: bgColor,
      color: sList.map(s=>s.color),
      textStyle:{ fontFamily:t.fontFamily },
      stateAnimation: { duration: 220, easing: 'cubicOut' },
      grid:{ left:40, right: (isNarrow ? 20 : 260), top: gridTop, bottom: (isNarrow ? legendReserveBottomPx : 40) },
      title: { text: titleText, left: 'center', top: titleTop,
        textStyle: { color: t.axisLabel, fontSize: titleFontSize, fontWeight: titleFontWeight, fontFamily: t.fontFamily } },
      legend: legendCfg,
      xAxis:{
        type:'value', name:xName, nameLocation:'middle', nameGap:25, nameMoveOverlap:true,
        nameTextStyle:{ color:t.axisName, fontWeight:600, fontFamily:t.fontFamily, textShadowColor:'rgba(0,0,0,0.28)', textShadowBlur:4, textShadowOffsetY:1 },
        axisLabel:{ color:t.axisLabel, fontSize:12, fontFamily:t.fontFamily, margin:10 },
        axisLine:{ lineStyle:{ color:t.axisLine }},
        splitLine:{ show:true, lineStyle:{ color:t.gridLine }},
        min: 0, max: built.xMax * 1.2
      },
      yAxis:{
        type:'value', name:'风量(CFM)', min:0, max: built.yMax * 1.3,
        nameTextStyle:{ color:t.axisName, fontWeight:600, textShadowColor:'rgba(0,0,0,0.28)', textShadowBlur:4, textShadowOffsetY:1 },
        axisLabel:{ color:t.axisLabel }, axisLine:{ lineStyle:{ color:t.axisLine }},
        splitLine:{ show:true, lineStyle:{ color:t.gridLine }}
      },
      tooltip:{
        axisPointer: { type: "cross", label: { color: t.tooltipText } },
        trigger:'item',
        backgroundColor:t.tooltipBg,
        borderColor:t.tooltipBorder,
        textStyle:{ color:t.tooltipText },
        extraCssText:`box-shadow:${t.tooltipShadow};`,
        formatter:function(p){
          const xModeNow = currentXModeFromPayload(lastPayload);
          const xLabel = xModeNow==='rpm' ? 'RPM, ' : 'dB, ';
          const infoLabel = xModeNow==='rpm' ? 'dB' : 'RPM';
          const x = p.value?.[0], y = p.value?.[1];
          const tip = p.data?.tip ?? '';
          const dot = `<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${p.color};margin-right:4px;"></span>`;
          return `${dot}${p.seriesName}<br/>&nbsp;&nbsp;&nbsp;&nbsp;${y}CFM @${x}${xLabel}${tip}${infoLabel}`;
        }
      },
      toolbox:{
        top: -5, right: 0,
        feature:{
          dataZoom:{ yAxisIndex:'none' },
          restore:{},
          saveAsImage:{ backgroundColor:bgColor, pixelRatio: window.devicePixelRatio || 1 },
          myFullscreen: {
            show: true,
            title: !!document.fullscreenElement ? '退出全屏' : '全屏查看',
            icon: !!document.fullscreenElement ? iconExit : iconEnter,
            onclick: () => toggleFullscreen()
          }
        }
      },
      dataZoom: [
        { type: 'inside', xAxisIndex: 0, throttle: 50, zoomOnMouseWheel: true, moveOnMouseWheel: true, moveOnMouseMove: true ,filterMode: "none", startValue: built.xMin, endValue: built.xMax },
        { type: 'inside', yAxisIndex: 0, throttle: 50, zoomOnMouseWheel: 'alt', moveOnMouseWheel: 'alt', moveOnMouseMove: true ,filterMode: "none", endValue: built.yMax}
      ],
      series: finalSeries
    };
  }

  function getExportBg() {
    const bg = getComputedStyle(document.body).backgroundColor;
    return bg && bg !== 'rgba(0, 0, 0, 0)' ? bg : '#ffffff';
  }

  function render(payload){
    if (!chart) init();
    const prevXMode = currentXModeFromPayload(lastPayload);
    const prevEmpty = !!(lastOption && lastOption.__empty);
    lastPayload = payload || lastPayload;
    syncThemeAttr((lastPayload && lastPayload.theme) || 'light');

    if (!fitUIInstalled) { ensureFitUI(); fitUIInstalled = true; }

    if (payload && payload.shareMeta && !shareInitializedFromMeta){
      const sm = payload.shareMeta;
      if (typeof sm.show_raw_curves === 'boolean') showRawCurves = sm.show_raw_curves;
      if (typeof sm.show_fit_curves === 'boolean') showFitCurves = sm.show_fit_curves;
      if (typeof sm.pointer_x_rpm === 'number') xQueryByMode.rpm = sm.pointer_x_rpm;
      if (typeof sm.pointer_x_noise_db === 'number') xQueryByMode.noise_db = sm.pointer_x_noise_db;
      if (Array.isArray(sm.legend_hidden_keys)) {
        shareLegendHiddenKeys = new Set(sm.legend_hidden_keys.map(String));
      }
      shareInitializedFromMeta = true;
      syncFitButtonsUI();
    }

    const option = buildOption(lastPayload);
    const nextXMode = currentXModeFromPayload(lastPayload);
    const nextEmpty = !!option.__empty;
    lastOption = option;

    if (prevXMode !== nextXMode || prevEmpty !== nextEmpty) {
      try { chart.clear(); } catch(_){}
    }
    chart.setOption(option, true);
    chart.resize();

    requestAnimationFrame(() => updateAxisSwitchPosition());
    if (option.__empty) {
      try { chart.dispatchAction({ type: 'updateAxisPointer', currTrigger: 'leave' }); } catch(_){}
    }
    const { x, y, visible } = computePrefixCenter(option);
    placeAxisOverlayAt(x, y, visible && !option.__empty);
    placeShareButton(option);

    lastIsNarrow = layoutIsNarrow();

    if (!layoutIsNarrow() && narrowDeferred.stored && !narrowDeferred.applied && !applyingDeferred){
      applyingDeferred = true;
      if (narrowDeferred.showRaw !== null) showRawCurves = narrowDeferred.showRaw;
      if (narrowDeferred.showFit !== null) showFitCurves = narrowDeferred.showFit;
      if (narrowDeferred.pointer.rpm != null) xQueryByMode.rpm = narrowDeferred.pointer.rpm;
      if (narrowDeferred.pointer.noise_db != null) xQueryByMode.noise_db = narrowDeferred.pointer.noise_db;
      narrowDeferred.applied = true;
      applyingDeferred = false;
      render(lastPayload);
      return;
    }

    toggleFitUI(showFitCurves && !layoutIsNarrow());
    placeFitUI();
    repaintPointer();
    if (showFitCurves) refreshFitBubble();
  }

  window.parent && window.parent.postMessage({ type:'chart:ready' }, window.location.origin);

  async function enterFullscreen(){
    const el = document.documentElement;
    try {
      await el.requestFullscreen(); isFs = true;
      if (isMobile() && screen.orientation && screen.orientation.lock) {
        try { await screen.orientation.lock('landscape'); } catch(_) {}
      }
    } catch(err){
      console.warn('requestFullscreen 失败：', err);
    } finally {
      if (lastPayload) render(lastPayload); else chart && chart.resize();
    }
  }
  async function exitFullscreen(){
    try { if (document.fullscreenElement) await document.exitFullscreen(); }
    catch(err){ console.warn('exitFullscreen 失败：', err); }
    finally {
      isFs = false;
      if (lastPayload) render(lastPayload); else chart && chart.resize();
    }
  }
  function toggleFullscreen(){
    if (document.fullscreenElement) exitFullscreen(); else enterFullscreen();
  }

  function computePrefixCenter(option){
    if (!chart || !option || !option.title) return { x: 0, y: 0, visible:false };
    if (option.__empty) return { x: 0, y: 0, visible:false };
    const title = option.title;
    const ts = title.textStyle || {};
    const size = Number(ts.fontSize || option.__titleFontSize || 14);
    const weight = ts.fontWeight || option.__titleFontWeight || 600;
    const family = ts.fontFamily || option.__titleFamily;
    const prefix = String(option.__titlePrefix || '');
    const totalText = `${prefix}${TITLE_GLUE}风量曲线`;
    const mTotal = measureText(totalText, size, weight, family);
    const mPrefix = measureText(prefix, size, weight, family);
    const chartW = chart.getWidth();
    const centerX = chartW / 2;
    const totalLeft = centerX - mTotal.width / 2;
    const prefixCenterX = totalLeft + mPrefix.width / 2;
    const top = (typeof title.top === 'number') ? title.top : 0;
    const centerY = top + (mTotal.height / 2);
    return { x: Math.round(prefixCenterX), y: Math.round(centerY), visible:true };
  }
  function syncThemeAttr(theme){
    const t = String(theme || 'light').toLowerCase();
    document.documentElement.setAttribute('data-theme', t);
    document.body.setAttribute('data-theme', t);
  }

  /* ========== 8. 拟合 UI / 指针 / 气泡（保留） ========== */
  function ensureNarrowHint(){
    const root = document.getElementById('chart');
    let hint = document.getElementById('narrowHint');
    if (!hint){
      hint = document.createElement('div');
      hint.id = 'narrowHint';
      hint.className = 'fit-narrow-hint';
      hint.textContent = `${FIT_ALGO_NAME}曲线请在图表右上角切换至全屏模式`;
      root.appendChild(hint);
    }
    return hint;
  }
  function ensureFitUI(){
    const root = document.getElementById('chart');
    let btns = document.getElementById('fitButtons');
    if (!btns){
      btns = document.createElement('div');
      btns.id = 'fitButtons';
      btns.className = 'fit-buttons';
      btns.innerHTML = `
        <button class="btn" id="btnRaw">ECHARTS<br>曲线</button>
        <button class="btn" id="btnFit">${FIT_ALGO_NAME}<br>曲线</button>
      `;
      root.appendChild(btns);
      const btnRaw = btns.querySelector('#btnRaw');
      const btnFit = btns.querySelector('#btnFit');
      function syncButtons(){ btnRaw.classList.toggle('active', showRawCurves); btnFit.classList.toggle('active', showFitCurves); }
      function ensureAtLeastOne(onWhich){
        if (!showRawCurves && !showFitCurves){
          if (onWhich === 'raw') showFitCurves = true; else showRawCurves = true;
        }
      }
      btnRaw.addEventListener('click', ()=>{
        showRawCurves = !showRawCurves;
        ensureAtLeastOne('raw');
        syncButtons();
        if (lastPayload) render(lastPayload);
        emitFitConfigChanged();  
      });
      btnFit.addEventListener('click', ()=>{
        showFitCurves = !showFitCurves;
        ensureAtLeastOne('fit');
        syncButtons();
        if (lastPayload) render(lastPayload);
        emitFitConfigChanged(); 
      });
      syncButtons();
    }
    let bubble = document.getElementById('fitBubble');
    if (!bubble){
      bubble = document.createElement('div');
      bubble.id = 'fitBubble';
      bubble.className = 'fit-bubble';
      bubble.innerHTML = `
        <div class="head">
          <div class="title">${FIT_ALGO_NAME} 估算值</div>
          <div class="x-input">
            <span>当前位置</span>
            <input id="fitXInput" type="number" step="1" />
            <span id="fitXUnit"></span>
          </div>
        </div>
        <div id="fitBubbleRows"></div>
        <div class="hint">按系列可见性（Legend）过滤，按风量从大到小排序</div>
      `;
      root.appendChild(bubble);
      bindBubbleDrag(bubble);
      const xInput = bubble.querySelector('#fitXInput');
      xInput.addEventListener('input', onBubbleInputLive);
      xInput.addEventListener('change', onBubbleInputCommit);
      xInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') { onBubbleInputCommit(); } });
    }
    let ptr = document.getElementById('fitPointer');
    if (!ptr){
      ptr = document.createElement('div');
      ptr.id = 'fitPointer';
      ptr.className = 'fit-pointer';
      ptr.innerHTML = `
        <div class="line"></div>
        <div class="handle" id="fitPointerHandle"></div>
      `;
      root.appendChild(ptr);
      bindPointerDrag();
    }
  }
  function syncFitButtonsUI(){
    const btnRaw = document.getElementById('btnRaw');
    const btnFit = document.getElementById('btnFit');
    if (btnRaw) btnRaw.classList.toggle('active', !!showRawCurves);
    if (btnFit) btnFit.classList.toggle('active', !!showFitCurves);
  }
  function bindBubbleDrag(bubble){
    if (!bubble) return;
    let activePointerId = null;
    let startX = 0, startY = 0;
    let baseLeft = 0, baseTop = 0;
    let dragging = false;
    const DRAG_THRESHOLD = 4;
    function isInteractiveTarget(el){ return !!(el && (el.closest('input, textarea, select, button, [contenteditable]'))); }
    function onPointerDown(e){
      if (e.button !== undefined && e.button !== 0) return;
      if (isInteractiveTarget(e.target)) return;
      const rect = bubble.getBoundingClientRect();
      startX = e.clientX; startY = e.clientY;
      baseLeft = rect.left; baseTop = rect.top;
      dragging = false;
      activePointerId = e.pointerId ?? null;
      try { if (activePointerId != null) bubble.setPointerCapture(activePointerId); } catch(_){}
    }
    function onPointerMove(e){
      if (activePointerId != null && (e.pointerId ?? null) !== activePointerId) return;
      if (activePointerId == null) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      if (!dragging && Math.hypot(dx, dy) > DRAG_THRESHOLD){
        dragging = true;
        bubble.classList.add('dragging');
      }
      if (!dragging) return;
      const bw = bubble.offsetWidth  || 0;
      const bh = bubble.offsetHeight || 0;
      const vw = window.innerWidth   || document.documentElement.clientWidth  || 0;
      const vh = window.innerHeight  || document.documentElement.clientHeight || 0;
      let newLeft = baseLeft + dx;
      let newTop  = baseTop  + dy;
      newLeft = Math.min(Math.max(0, newLeft), Math.max(0, vw - bw));
      newTop  = Math.min(Math.max(0, newTop ), Math.max(0, vh - bh));
      bubble.style.left = Math.round(newLeft) + 'px';
      bubble.style.top  = Math.round(newTop)  + 'px';
      bubble.style.right  = 'auto';
      bubble.style.bottom = 'auto';
      bubblePos.left = newLeft;
      bubblePos.top  = newTop;
      bubbleUserMoved = true;
    }
    function endDrag(){
      if (activePointerId == null) return;
      try { bubble.releasePointerCapture(activePointerId); } catch(_){}
      activePointerId = null;
      dragging = false;
      bubble.classList.remove('dragging');
    }
    bubble.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove, { passive:false });
    window.addEventListener('pointerup',   endDrag,       { passive:true  });
    window.addEventListener('pointercancel', endDrag,     { passive:true  });
    window.addEventListener('blur', endDrag);
  }
  function toggleFitUI(showFit){
    const btns = document.getElementById('fitButtons');
    const bubble = document.getElementById('fitBubble');
    const ptr = document.getElementById('fitPointer');
    const narrow = layoutIsNarrow();
    const empty  = !lastOption || lastOption.__empty;
    if (btns) btns.style.visibility = (empty || narrow) ? 'hidden' : 'visible';
    const showFloating = showFit && !narrow && !empty;
    if (bubble) bubble.style.visibility = showFloating ? 'visible' : 'hidden';
    if (ptr)    ptr.style.visibility    = showFloating ? 'visible' : 'hidden';
  }
  function placeFitUI(){
    const btns = document.getElementById('fitButtons');
    const bubble = document.getElementById('fitBubble');
    if (!lastOption) return;
    const grid = lastOption.grid || { left:40, right: 260, top: 60, bottom: 40 };
    const chartW = chart ? chart.getWidth() : 800;
    const chartH = chart ? chart.getHeight() : 600;
    const left = (typeof grid.left==='number') ? grid.left : 40;
    const rightGap = (typeof grid.right==='number') ? grid.right : 260;
    const top = (typeof grid.top==='number') ? grid.top : 60;
    const bottomGap = (typeof grid.bottom==='number') ? grid.bottom : 40;
    const pad = 6;
    if (btns){
      btns.style.right = '20px';
      btns.style.bottom = '20px';
      btns.style.visibility = (lastOption.__empty || layoutIsNarrow()) ? 'hidden' : 'visible';
    }
    if (bubble){
      bubble.style.position = 'fixed';
      const bw2 = bubble.offsetWidth  || 0;
      const bh2 = bubble.offsetHeight || 0;
      if (!bubbleUserMoved){
        const preferredX = left + 2;
        const preferredY = top  + 2;
        const vw = window.innerWidth  || document.documentElement.clientWidth  || chartW;
        const vh = window.innerHeight || document.documentElement.clientHeight || chartH;
        const bx = Math.min(Math.max(pad, preferredX), Math.max(pad, vw - bw2 - pad));
        const by = Math.min(Math.max(pad, preferredY), Math.max(pad, vh - bh2 - pad));
        bubble.style.left = bx + 'px';
        bubble.style.top  = by + 'px';
        bubble.style.right  = 'auto';
        bubble.style.bottom = 'auto';
        bubblePos.left = bx; bubblePos.top = by;
      } else {
        const vw = window.innerWidth  || document.documentElement.clientWidth  || chartW;
        const vh = window.innerHeight || document.documentElement.clientHeight || chartH;
        const bx = Math.min(Math.max(pad, bubblePos.left || 0), Math.max(pad, vw - bw2 - pad));
        const by = Math.min(Math.max(pad, bubblePos.top  || 0), Math.max(pad, vh - bh2 - pad));
        bubble.style.left = Math.round(bx) + 'px';
        bubble.style.top  = Math.round(by) + 'px';
        bubble.style.right  = 'auto';
        bubble.style.bottom = 'auto';
        bubblePos.left = bx; bubblePos.top = by;
      }
      bubble.style.visibility = (showFitCurves && !lastOption.__empty) ? 'visible' : 'hidden';
      const unit = (currentXModeFromPayload(lastPayload) === 'rpm') ? 'RPM' : 'dB';
      const unitSpan = bubble.querySelector('#fitXUnit');
      if (unitSpan) unitSpan.textContent = unit;
    }
    const hint = ensureNarrowHint();
    const narrow = layoutIsNarrow();
    if (narrow && !lastOption.__empty) {
      const x = chartW - rightGap - (hint.offsetWidth || 0) - 6;
      const y = chartH - bottomGap - 14;
      hint.style.left = Math.max(2, x) + 'px';
      hint.style.top  = Math.max(2, y) + 'px';
      hint.style.visibility = 'visible';
    } else {
      hint.style.visibility = 'hidden';
    }
  }
  function bindPointerDrag(){
    const handle = document.getElementById('fitPointerHandle');
    if (!handle) return;
    let dragging=false, startX=0, baseX=0, activePointerId=null;
    function measureGrid(){
      if (!lastOption) return { left:40, right: (chart ? chart.getWidth() - 260 : 800), top: 60, height: 300 };
      const grid = lastOption.grid || { left:40, right: 260, top: 60, bottom: 40 };
      const chartW = chart ? chart.getWidth() : 800;
      const chartH = chart ? chart.getHeight() : 600;
      const left = (typeof grid.left==='number') ? grid.left : 40;
      const rightGap = (typeof grid.right==='number') ? grid.right : 260;
      const top = (typeof grid.top==='number') ? grid.top : 60;
      const bottomGap = (typeof grid.bottom==='number') ? grid.bottom : 40;
      const right = chartW - rightGap;
      const height = chartH - top - bottomGap;
      return { left, right, top, height };
    }
    function onDown(e){
      if (e.button !== undefined && e.button !== 0) return;
      dragging = true;
      activePointerId = e.pointerId ?? null;
      startX = e.clientX;
      const ptr = document.getElementById('fitPointer');
      baseX = parseFloat(ptr?.style.left || '0');
      handle.style.cursor = 'grabbing';
      try { if (activePointerId != null) handle.setPointerCapture(activePointerId); } catch(_){}
      e.preventDefault?.();
    }
    function onMove(e){
      if (!dragging) return;
      const grid = measureGrid();
      const dx = e.clientX - startX;
      let x = baseX + dx;
      x = Math.max(grid.left, Math.min(x, grid.right));
      const ptr = document.getElementById('fitPointer');
      ptr.style.left = x + 'px';
      const xVal = pxToDataX(x);
      const mode = currentXModeFromPayload(lastPayload);
      if (Number.isFinite(xVal)) {
        xQueryByMode[mode] = clampXDomain(xVal);
        syncBubbleInput();
        if (showFitCurves) refreshFitBubble();
        emitPointerMoved(xQueryByMode[mode]);
      }
    }
    function onUp(){
      if (!dragging) return;
      dragging=false;
      handle.style.cursor = 'grab';
      try { if (activePointerId != null) handle.releasePointerCapture(activePointerId); } catch(_){}
      activePointerId=null;
    }
    function onCancel(){
      if (!dragging) return;
      dragging=false;
      handle.style.cursor = 'grab';
      try { if (activePointerId != null) handle.releasePointerCapture(activePointerId); } catch(_){}
      activePointerId=null;
    }
    handle.addEventListener('pointerdown', onDown);
    window.addEventListener('pointermove', onMove, { passive:true });
    window.addEventListener('pointerup', onUp, { passive:true });
    window.addEventListener('pointercancel', onCancel);
    window.addEventListener('blur', onCancel);
  }
  function repaintPointer(){
    const ptr = document.getElementById('fitPointer');
    if (!ptr || !lastOption) return;
    if (!showFitCurves || lastOption.__empty) { ptr.style.visibility = 'hidden'; return; }
    const grid = lastOption.grid || { left:40, right: 260, top: 60, bottom: 40 };
    const chartW = chart ? chart.getWidth() : 800;
    const chartH = chart ? chart.getHeight() : 600;
    const left = (typeof grid.left==='number') ? grid.left : 40;
    const rightGap = (typeof grid.right==='number') ? grid.right : 260;
    const top = (typeof grid.top==='number') ? grid.top : 60;
    const bottomGap = (typeof grid.bottom==='number') ? grid.bottom : 40;
    const height = chartH - top - bottomGap;
    const mode = currentXModeFromPayload(lastPayload);
    if (xQueryByMode[mode] == null) {
      const [vx0, vx1] = getVisibleXRange();
      xQueryByMode[mode] = (vx0 + vx1) / 2;
    }
    /*emitPointerMoved(xQueryByMode[mode]);*/  /*注释掉减少频率*/
    clampXQueryIntoVisibleRange();
    const xPixel = dataToPxX(xQueryByMode[mode]);
    ptr.style.left = xPixel + 'px';
    ptr.style.top = top + 'px';
    ptr.style.height = height + 'px';
    ptr.style.visibility = 'visible';
    syncBubbleInput();
    if (showFitCurves) refreshFitBubble();
  }
  function syncBubbleInput(){
    const inp = document.getElementById('fitXInput');
    if (!inp) return;
    const mode = currentXModeFromPayload(lastPayload);
    const val = Number(xQueryByMode[mode]);
    const rounded = (mode === 'noise_db') ? Number(val.toFixed(1)) : Math.round(val);
    inp.value = String(rounded);
    const [vx0, vx1] = getVisibleXRange();
    inp.setAttribute('min', String(Math.floor(vx0)));
    inp.setAttribute('max', String(Math.ceil(vx1)));
    inp.setAttribute('step', (mode === 'noise_db') ? '0.1' : '1');
  }
  function onBubbleInputLive(){
    const inp = document.getElementById('fitXInput');
    if (!inp) return;
    const mode = currentXModeFromPayload(lastPayload);
    const raw = Number(inp.value);
    if (!Number.isFinite(raw)) return;
    xQueryByMode[mode] = clampXDomain(raw);
    clampXQueryIntoVisibleRange();
    const xPixel = dataToPxX(xQueryByMode[mode]);
    const ptr = document.getElementById('fitPointer');
    if (ptr && Number.isFinite(xPixel)) ptr.style.left = xPixel + 'px';
    if (showFitCurves) refreshFitBubble();
    emitPointerMoved(xQueryByMode[mode]);
  }
  function onBubbleInputCommit(){
    repaintPointer();
    refreshFitBubble();
  }
  function refreshFitBubble(){
    const bubble = document.getElementById('fitBubble');
    if (!bubble || !showFitCurves || !lastPayload || !chart) return;
    const rowsEl = bubble.querySelector('#fitBubbleRows');
    const mode = currentXModeFromPayload(lastPayload);
    const x = xQueryByMode[mode];
    if (x == null) return;
    const sList = Array.isArray(lastPayload?.chartData?.series) ? lastPayload.chartData.series : [];
    ensureFitModels(sList, mode);
    const opt = chart.getOption() || {};
    const selMap = (opt.legend && opt.legend[0] && opt.legend[0].selected) || {};
    const items = [];
    sList.forEach(s => {
      const visible = (selMap[s.name] !== false);
      if (!visible) return;
      const model = fitModelsCache[mode].get(s.name);
      if (!model || model.x0 == null || model.x1 == null) return;
      const x0 = Math.min(model.x0, model.x1);
      const x1 = Math.max(model.x0, model.x1);
      let y = NaN;
      if (x >= x0 && x <= x1) {
        y = evalModelY(model, x);
      }
      items.push({ name: s.name, color: s.color, y });
    });
    const fmt = (v)=> Math.round(v);
    const withVal = items.filter(it => Number.isFinite(it.y)).sort((a,b)=> b.y - a.y);
    const noVal   = items.filter(it => !Number.isFinite(it.y));
    const base = (withVal.length && withVal[0].y > 0) ? withVal[0].y : 0;
    const pctVal = (v)=> (Number.isFinite(v) && base > 0) ? Math.round((v / base) * 100) : null;
    const valTexts = items.map(it => Number.isFinite(it.y) ? `${fmt(it.y)} CFM` : '-');
    const maxValChars = valTexts.reduce((m,s)=>Math.max(m, s.length), 1);
    const pctWidthCh = 6;
    const ordered = withVal.concat(noVal);
    rowsEl.innerHTML = ordered.map(it => {
      const has = Number.isFinite(it.y);
      const valText = has ? `${fmt(it.y)} CFM` : '-';
      const pct = has ? pctVal(it.y) : null;
      const pctText = (pct==null) ? '-' : `(${pct}%)`;
      return `
        <div class="row">
          <span class="dot" style="background:${it.color}"></span>
          <span>${it.name}</span>
          <span style="margin-left:auto; display:inline-flex; align-items:center; gap:8px;">
            <span style="min-width:${maxValChars}ch; text-align:right; font-weight:800; font-variant-numeric:tabular-nums;">${valText}</span>
            <span style="width:${pctWidthCh}ch; text-align:right; font-variant-numeric:tabular-nums;">${pctText}</span>
          </span>
        </div>
      `;
    }).join('');
  }

  /* ========== 9. 拟合算法（保留原版） ========== */
  function ensureFitModels(sList, xMode){
    const models = fitModelsCache[xMode];
    sList.forEach(s => {
      if (models.has(s.name)) return;
      const xsRaw = (s[xMode] || []).map(Number);
      const ysRaw = (s.airflow || []).map(Number);
      const pairs = [];
      const n = Math.min(xsRaw.length, ysRaw.length);
      for (let i=0;i<n;i++){
        const x = xsRaw[i], y = ysRaw[i];
        if (Number.isFinite(x) && Number.isFinite(y)) pairs.push([x, y]);
      }
      if (!pairs.length) return;
      pairs.sort((a,b)=> a[0]-b[0]);
      const xs = [], ys = [];
      for (let i=0;i<pairs.length;i++){
        const [x,y] = pairs[i];
        if (xs.length && Math.abs(x - xs[xs.length-1]) < 1e-9){
          ys[ys.length-1] = (ys[ys.length-1] + y) / 2;
        } else {
          xs.push(x); ys.push(y);
        }
      }
      const U = xs.length;
      const x0 = xs[0], x1 = xs[U-1];
      if (U === 1){
        models.set(s.name, { type:'linear', a: ys[0], b: 0, x0, x1: x0 + 1 });
        return;
      }
      if (xMode === 'rpm'){
        const { a, b: bRaw } = olsLinear(xs, ys);
        const b = Math.max(0, Number.isFinite(bRaw) ? bRaw : 0);
        models.set(s.name, { type:'linear', a, b, x0, x1 });
        return;
      }
      let best = null;
      const q = olsQuadratic(xs, ys);
      if (q){
        const sseQ = xs.reduce((acc, xv, i)=>{ const r = ys[i] - (q.a + q.b*xv + q.c*xv*xv); return acc + r*r; }, 0);
        best = { type:'quad', a:q.a, b:q.b, c:q.c, sse:sseQ };
      }
      const lg = olsLog(xs, ys);
      if (lg){
        const sseL = xs.reduce((acc, xv, i)=>{ const r = ys[i] - (lg.a + lg.b*Math.log(Math.max(1e-9, xv - lg.shift))); return acc + r*r; }, 0);
        if (!best || sseL < best.sse) best = { type:'log', a:lg.a, b:lg.b, shift:lg.shift, sse:sseL };
      }
      if (!best){
        const { a, b } = olsLinear(xs, ys);
        models.set(s.name, { type:'linear', a, b: Math.max(0,b), x0, x1 });
        return;
      }
      if (best.type === 'quad') {
        models.set(s.name, { type:'quad', a:best.a, b:best.b, c:best.c, x0, x1 });
      } else {
        models.set(s.name, { type:'log', a:best.a, b:best.b, shift:best.shift, x0, x1 });
      }
    });
  }
  function computeSampleCount(widthPx){
    const n = Math.round(widthPx / 1.5);
    return Math.max(200, Math.min(1200, n));
  }
  function resampleSingle(model, xmin, xmax, count){
    const n = Math.max(2, count|0);
    const pts = [];
    const x0 = Math.max(xmin, model.x0 ?? xmin);
    const x1 = Math.min(xmax, model.x1 ?? xmax);
    for (let i=0;i<n;i++){
      const t = i/(n-1);
      const x = x0 + (x1 - x0) * t;
      const y = evalModelY(model, x);
      pts.push({ x, y });
    }
    return pts;
  }
  function evalModelY(model, x){
    if (!model) return NaN;
    switch (model.type) {
      case 'linear': return model.a + model.b * x;
      case 'quad':   return model.a + model.b * x + model.c * x * x;
      case 'log':    return model.a + model.b * Math.log(Math.max(1e-9, x - model.shift));
      default: return NaN;
    }
  }
  function olsLinear(xs, ys){
    const n = xs.length;
    let sumx=0,sumy=0,sumxx=0,sumxy=0;
    for (let i=0;i<n;i++){ const x=xs[i], y=ys[i]; sumx+=x; sumy+=y; sumxx+=x*x; sumxy+=x*y; }
    const denom = n*sumxx - sumx*sumx;
    let b = (Math.abs(denom) > 1e-12) ? (n*sumxy - sumx*sumy)/denom : 0;
    let a = (sumy - b*sumx)/n;
    return { a, b };
  }
  function olsQuadratic(xs, ys){
    const n = xs.length;
    let S1=0,Sx=0,Sxx=0,Sxxx=0,Sxxxx=0,Sy=0,Sxy=0,Sxxy=0;
    for (let i=0;i<n;i++){
      const x = xs[i], y = ys[i];
      const x2 = x*x, x3 = x2*x, x4 = x2*x2;
      S1+=1; Sx+=x; Sxx+=x2; Sxxx+=x3; Sxxxx+=x4; Sy+=y; Sxy+=x*y; Sxxy+=x2*y;
    }
    const M = [
      [ S1,   Sx,   Sxx  ],
      [ Sx,   Sxx,  Sxxx ],
      [ Sxx,  Sxxx, Sxxxx ]
    ];
    const b = [ Sy, Sxy, Sxxy ];
    const sol = solve3x3(M, b);
    if (!sol) return null;
    return { a: sol[0], b: sol[1], c: sol[2] };
  }
  function olsLog(xs, ys){
    const n = xs.length;
    const xmin = Math.min.apply(null, xs);
    const shift = xmin - 1;
    let sumz=0,sumzz=0,sumy=0,sumzy=0;
    for (let i=0;i<n;i++){
      const z = Math.log(Math.max(1e-9, xs[i] - shift));
      const y = ys[i];
      sumz += z; sumzz += z*z; sumy += y; sumzy += z*y;
    }
    const denom = n*sumzz - sumz*sumz;
    if (Math.abs(denom) < 1e-12) return null;
    const b = (n*sumzy - sumz*sumy)/denom;
    const a = (sumy - b*sumz)/n;
    return { a, b, shift };
  }
  function solve3x3(M, b){
    const A = [M[0].slice(), M[1].slice(), M[2].slice()];
    const y = b.slice();
    for (let i=0;i<3;i++){
      let piv=i; for (let r=i+1;r<3;r++) if (Math.abs(A[r][i])>Math.abs(A[piv][i])) piv=r;
      if (Math.abs(A[piv][i])<1e-12) return null;
      if (piv!==i){ const t=A[i]; A[i]=A[piv]; A[piv]=t; const ty=y[i]; y[i]=y[piv]; y[piv]=ty; }
      const div=A[i][i];
      for (let c=i;c<3;c++) A[i][c]/=div; y[i]/=div;
      for (let r=i+1;r<3;r++){ const f=A[r][i]; for (let c=i;c<3;c++) A[r][c]-=f*A[i][c]; y[r]-=f*y[i]; }
    }
    const x = new Array(3);
    for (let i=2;i>=0;i--){ let s=y[i]; for (let c=i+1;c<3;c++) s-=A[i][c]*x[c]; x[i]=s; }
    return x;
  }

  /* ========== 10. Visible range & clamp 工具 ========== */
  function pxToDataX(xPixel){
    try { return chart.convertFromPixel({ xAxisIndex: 0 }, xPixel); } catch(e){ return NaN; }
  }
  function dataToPxX(xData){
    try { return chart.convertToPixel({ xAxisIndex: 0 }, xData); } catch(e){ return NaN; }
  }
  function clampXDomain(val){
    if (!lastOption) return val;
    const xAxis = lastOption.xAxis || {};
    const xmin = Number(xAxis.min); const xmax = Number(xAxis.max);
    if (!Number.isFinite(xmin) || !Number.isFinite(xmax)) return val;
    return Math.max(xmin, Math.min(val, xmax));
  }
  function getVisibleXRange(){
    if (!lastOption) return [0,1];
    const xAxis = lastOption.xAxis || {};
    const xmin = Number(xAxis.min); const xmax = Number(xAxis.max);
    let vmin = xmin, vmax = xmax;
    const opt = chart.getOption() || {};
    const dz = (opt.dataZoom||[]).find(z => z.xAxisIndex === 0 || (z.xAxisIndex||0)===0) || null;
    if (dz && typeof dz.start === 'number' && typeof dz.end === 'number') {
      const span = xmax - xmin;
      vmin = xmin + span * (dz.start/100);
      vmax = xmin + span * (dz.end/100);
    }
    return [vmin, vmax];
  }
  function clampXQueryIntoVisibleRange(){
    const mode = currentXModeFromPayload(lastPayload);
    if (xQueryByMode[mode] == null) return;
    const [vmin, vmax] = getVisibleXRange();
    if (xQueryByMode[mode] < vmin) xQueryByMode[mode] = vmin;
    if (xQueryByMode[mode] > vmax) xQueryByMode[mode] = vmax;
  }

  function emitFitConfigChanged(){
    try {
      window.parent.postMessage({
        type:'chart:fit-config-changed',
        payload:{ show_raw: showRawCurves, show_fit: showFitCurves }
      }, window.location.origin);
    } catch(_) {}
  }
  function emitPointerMoved(val){
    const axisType = currentXModeFromPayload(lastPayload);
    if (typeof val !== 'number' || !isFinite(val)) return;
    try {
      window.parent.postMessage({
        type:'chart:pointer-moved',
        payload:{ x_axis_type: axisType, value: val }
      }, window.location.origin);
    } catch(_) {}
  }
  /* ========== 11. 消息通信 ========== */
  window.addEventListener('message', (e)=>{
    if (e.origin !== window.location.origin) return;
    const { type, payload } = e.data || {};
    if (type==='chart:update' && payload) render(payload);
    if (type==='chart:resize' && chart) handleLayoutMutation();
  });

  document.addEventListener('DOMContentLoaded', init);
})();
</script>
</body>
</html>